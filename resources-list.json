{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%20syncCacheProvider%20%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "Web Widget 架构设计与 syncCacheProvider 机制深度解析",
        "description": "核心知识点：- **Web Widget 核心定位**：基于 Web Components 标准的微模块方案，解决 Monorepo 项目中跨团队协作、跨框架混合运行（如 React 中运行 Vue）及渐进式迁移问题。\n- **实现原理**：\n  - **HTMLWebWidgetElement**：自定义元素作为容器，管理 Widget 的生命周期状态（LOADING, LOADED, BOOTSTRAPPED, MOUNTED）。\n  - **生命周期协议**：标准化 `bootstrap`、`mount`、`unmount` 钩子，屏蔽框架差异。\n  - **适配器模式**：通过 `toReact` 等 HOC 在 React 生命周期内管理 Vue 实例，同步 Props 并桥接事件。\n- **syncCacheProvider 机制**：\n  - **SSR 阶段**：阻塞执行 fetcher，将数据存入 `lifecycleCache` 并序列化至 HTML 的 JSON 状态中。\n  - **CSR 阶段**：首屏加载从 JSON 恢复缓存，`syncCacheProvider` 命中缓存后同步返回数据，消除白屏闪烁。若无缓存则退化为异步 Promise。\n- **性能优化**：支持 `loading=\"lazy\"` 按需激活（Hydration），仅在进入视口时初始化运行时。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Layer%20Picker%20%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96.md",
        "name": "Layer Picker 碰撞检测实现原理与优化",
        "description": "核心知识点：### 1. Color Picking 技术原理\n- **核心思想**：为每个可交互元素分配唯一颜色 ID，将所有元素绘制到离屏 Canvas（hitCanvas），点击时读取像素颜色反向查找元素\n- **优势**：精确、统一、高效，可处理不规则形状和透明区域\n- **关键组件**：LayerPicker 类、colorImage 着色函数、transformLayer 变换函数、getLayers 图层提取\n\n### 2. 图像着色算法（colorImage）\n- 通过 **反复绘制自身**（默认15次）消除半透明像素，使 alpha 趋近于 1\n- 使用 `source-in` 混合模式将图像着色为指定颜色\n- 添加 `shadowBlur` 扩展边缘，提高边缘检测精度\n\n### 3. 反复绘制的性能问题\n- 每个元素需要 15 次 `drawImage` 调用，N 个图像需要 15N 次\n- 时间复杂度：O(repeatDrawCount × width × height × N)\n\n### 4. 优化方案对比\n\n| 方案 | 原理 | 性能提升 | 复杂度 |\n|------|------|----------|--------|\n| **ImageData 像素操作** | 直接遍历像素，alpha > 0 设为 255 | ★★★☆☆ | 低 |\n| **lighter 混合模式** | alpha 直接相加，5次即可达到1.0 | ★★★☆☆ | 低 |\n| **WebGL Shader** | GPU 并行处理，fragment shader 着色 | ★★★★★ | 高 |\n| **增量更新** | 缓存已着色结果，只处理变更图层 | ★★★★☆ | 中 |\n\n### 5. Canvas 混合模式的 Alpha 计算\n\n| 模式 | Alpha 公式 | α=0.5 结果 | 效果 |\n|------|------------|------------|------|\n| source-over | `α + α × (1 - α)` | 0.75 | 增加 |\n| **lighter** | `α + α` (clamp to 1) | 1.0 | **增加最快** |\n| screen | `α + α - α × α` | 0.75 | 增加 |\n| multiply | `α × α` | 0.25 | 减少 |\n\n- **lighter 模式最高效**：5次即可将 α=0.1 提升到 1.0（source-over 需要15+次）\n- **无法直接实现 alpha 二值化**：标准混合模式都是连续函数，需配合 ImageData 或 Shader\n\n### 6. 模糊匹配机制\n\n**触发原因**（读取像素颜色与存储颜色不匹配）：\n- 半透明像素与背景混合导致颜色偏移\n- 抗锯齿产生边缘中间色\n- zoom 缩放时浏览器颜色插值\n- 多图层边缘重叠混合\n- `getImageData` 采样边界像素\n\n**保留必要性**：\n- 即使 colorImage 输出完美纯色，后续绘制/采样环节仍可能引入偏差\n- 模糊匹配是整个流程中颜色精度损失的**兜底机制**\n- 配合 `imageSmoothingEnabled = false` 可大幅减少触发频率\n\n### 7. 推荐优化路径\n1. **短期**：将反复绘制替换为 lighter 模式（5次）或 ImageData 像素操作\n2. **中期**：实现增量更新机制，避免全量重绘\n3. **长期**：考虑 WebGL 统一方案",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BB%B7%E5%80%BC%EF%BC%88%E5%85%A8%E9%87%8F%E6%80%9D%E8%80%83%E7%89%88%EF%BC%89.md",
        "name": "Kubernetes (K8s) 核心概念与价值（全量思考版）",
        "description": "核心知识点：- **Kubernetes (K8s) 定义**：开源容器编排平台，用于自动化部署、扩展和管理容器化应用。\n- **架构组成**：\n  - **Control Plane (控制平面)**：决策中心。\n  - **Nodes (节点)**：运行环境，包含 Kubelet 和容器运行时。\n- **核心对象**：\n  - **Pod**：最小调度单位，共享网络和存储。\n  - **Controllers**：Deployment (无状态), StatefulSet (有状态), DaemonSet (全节点副本)。\n  - **Service & Ingress**：服务发现、负载均衡与外部路由管理。\n- **核心价值**：解决大规模容器管理中的自动化运维、服务发现、高可用自愈、资源利用率优化、版本发布风险控制及环境一致性问题。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/CSS%20%E5%B8%83%E5%B1%80%E4%B8%8E%20Grid%20%E7%80%91%E5%B8%83%E6%B5%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "CSS 布局与 Grid 瀑布流深度解析",
        "description": "核心知识点：- **Flex 布局收缩规则 (flex-shrink)**：\n  - 计算公式：`加权收缩量 = 溢出空间 * (flex-basis * flex-shrink) / 总加权值`。\n  - 默认 `flex-shrink: 1`。若所有子元素收缩比例之和小于 1，溢出空间不会被完全吸收。\n  - 易错点：`min-width` 默认为 `auto`，长文本溢出常导致收缩失效，需手动设为 `0`。\n- **Grid 布局核心特性**：\n  - **二维布局**：同时处理行和列。\n  - **自适应黑科技**：`repeat(auto-fill, minmax(200px, 1fr))` 实现无需媒体查询的响应式网格。\n  - **auto-fill vs auto-fit**：`auto-fill` 即使格子为空也保留（留白），`auto-fit` 会折叠空格子（拉伸）。\n- **Grid 瀑布流 (Masonry)**：\n  - `grid-template-rows: masonry` 是 Level 3 规范，允许网格行不再强制对齐，自动填充空隙。\n  - 目前仅 Firefox 实验性支持，生产环境通常需配合 JS 计算 `grid-row-end: span N`。\n- **面试易混淆点**：\n  - `flex: 1` 等价于 `flex-grow: 1; flex-shrink: 1; flex-basis: 0%;`。\n  - `flex-basis` 优先级高于 `width`，但受 `min/max-width` 限制。\n  - `margin: auto` 在 Flex/Grid 容器中可实现垂直水平双向居中。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/%E7%A8%BF%E5%AE%9A%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95(Extension)%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90.md",
        "name": "稿定编辑器扩展(Extension)系统架构设计与链路分析",
        "description": "核心知识点：### 1. 扩展系统三层架构\n\n| 包/目录 | 定位 | 核心内容 |\n|---------|------|----------|\n| `packages/design/extension` | **运行时核心** | `ExtensionManager`、`Extension`、`ExtensionApi`、入口注册 hooks |\n| `packages/design/extension-store` | **状态管理** | Pinia Store，管理菜单/入口的注册、启用/禁用 |\n| `extensions/*` | **扩展实现** | 每个子目录是一个独立扩展，包含 `manifest.json` + `src/index.ts` |\n\n### 2. 三个核心类职责\n\n- **ExtensionManager**：集中管理所有扩展的加载、注册、运行、卸载，维护 `Map<id, Extension>` 映射表\n- **Extension**：单个扩展实例封装，管理生命周期状态（init/register/bootstrap/run/unmount）\n- **ExtensionApi**：扩展可调用的 API 上下文，桥接编辑器核心能力，提供 100+ API 方法\n\n### 3. 扩展生命周期\n\n```\nload → register → bootstrap（懒加载）→ run → unmount\n```\n\n- **load**：解析 ExtensionConfig，创建 Extension 实例\n- **register**：调用 beforeRegister/afterRegister 钩子，注册 UI 入口（此时扩展代码尚未执行）\n- **bootstrap**：用户首次交互时才动态加载代码并执行 activate()\n- **run**：执行具体命令\n- **unmount**：清理所有注册项\n\n### 4. Manifest 声明规范\n\n```typescript\ninterface Manifest<T> {\n  id: string;\n  name: string;\n  main: (options?: T) => Promise<{ activate: (ctx: ExtensionAPI, options?: T) => void }>;\n  ui?: Record<string, () => Promise<{ ResourceStationView?; SettingContainerView? }>> | string;\n  entries?: Partial<Record<EntryTypes, Entry[]>>;\n  commands?: Record<string, { title: string; icon?: string; when?: string; }>;\n  beforeRegister?: (ctx?: ExtensionAPI, options?: T) => void;\n  afterRegister?: (api: ExtensionAPI, options?: T) => void;\n}\n```\n\n### 5. 入口类型（EntryTypes）\n\n- `ResourceActivityBar`：左侧资源栏\n- `SettingContainer`：右侧设置面板\n- `EditorToolbar`：编辑器 toolbar\n- `EditorContextmenu`：右键菜单\n- `FileMenu`：左上角文件菜单\n- `ExportAction`：下载按钮\n- `EditorAddTools`：左侧添加工具\n- `FilterResourceSlot` / `ComponentResourceSlot`：插槽组件\n\n### 6. JS ↔ UI 通信机制\n\n扩展分离为 JS 层（逻辑）和 UI 层（Vue 组件），通过事件系统通信：\n\n```\nJS 层                           UI 层\nctx.postMessage() ────────────► props.on()\nctx.on()          ◄──────────── props.postMessage()\n```\n\nUI 组件通过 props 接收通信方法（`postMessage`、`postMessageToJSAsync`、`on`、`once`）。\n\n### 7. text-rewrite 扩展完整链路\n\n1. **注册阶段**：afterRegister 中注册 4 类入口（属性面板、右键菜单、toolbar、编辑器插件）\n2. **用户触发**：点击任一入口 → openTextRewrite() → 检查登录 → showElementEditor()\n3. **插件激活**：监听 element.$editing && $editingType === 'aiTextRewrite'\n4. **UI 挂载**：onMounted → 隐藏 toolbar → 禁用属性面板 → 调用 OCR API\n5. **OCR 识别**：调用 `new-image-ocr` 接口，解析文字坐标和内容\n6. **用户编辑**：显示 Popup 弹窗，用户修改文本\n7. **AI 生成**：点击应用 → 调用 `TextEdit` API → 插入新元素 → 应用结果\n\n### 8. 设计亮点\n\n| 特性 | 说明 |\n|------|------|\n| 懒加载 | 扩展代码在用户首次交互时才加载执行 |\n| 声明式入口 | 通过 manifest.entries 声明 UI 挂载点 |\n| API 沙箱 | ExtensionApi 作为中间层隔离扩展与编辑器内核 |\n| 插件注册追踪 | registeredItems 统一管理，卸载时自动清理 |\n| 权限集成 | 入口注册时自动校验 permissionCode |",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/AI%20%E9%A2%86%E5%9F%9F%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%20RAG%20%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "AI 领域核心概念与 RAG 架构深度解析",
        "description": "核心知识点：- **LLM (大语言模型)**：AI 的“大脑”，负责语义理解与文本生成。演进从 RNN 到 Transformer，再到 GPT 系列，解决了机器理解自然语言的问题。\n- **Agent (智能体)**：以 LLM 为核心，具备规划、记忆和工具使用能力的系统。它让 AI 从“对话者”进化为“执行者”，能够自主完成复杂任务。\n- **Skill (技能)**：Agent 的专业插件或指令集。在 Cursor 中表现为 `.mdc` 规则文件，教导 AI 如何利用工具（如 MCP）完成特定业务流程。\n- **MCP (模型上下文协议)**：由 Anthropic 提出的开放标准，解决了 AI 与外部数据源（文件、数据库等）集成成本高、数据孤岛的问题，是 AI 的“神经通路”。\n- **幻觉 (Hallucination)**：指 AI 生成看似合理但事实错误的内容。原因包括训练数据过时、模型的概率预测本质、缺乏实时感知等。\n- **RAG (检索增强生成)**：通过“检索（找资料）+ 生成（总结回答）”的模式，给 AI 提供“开卷考试”的参考书，是降低幻觉、解决时效性问题的核心手段。\n- **RAG 编排器 (Orchestrator)**：负责 RAG 流程的工程化代码逻辑，包含问题改写、向量检索、重排序（Rerank）和提示词组装。它不是简单的 SQL，而是确定性的算法流程。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/HTTP%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.md",
        "name": "HTTP 缓存机制完全指南",
        "description": "核心知识点：### 1. HTTP 缓存请求头和响应头\n\n**响应头（Response Headers）**：\n- **Cache-Control**：最重要的缓存控制字段\n  - `max-age=<秒>`：缓存有效期（相对时间）\n  - `s-maxage=<秒>`：共享缓存（CDN）的有效期，优先级高于 max-age\n  - `no-cache`：可以缓存，但每次使用前必须验证\n  - `no-store`：禁止缓存\n  - `public`：可被任何缓存存储（包括 CDN）\n  - `private`：只能被浏览器缓存\n  - `must-revalidate`：过期后必须向服务器验证\n  - `immutable`：资源永远不会改变\n- **ETag**：资源的唯一标识符，支持强验证和弱验证（W/前缀）\n- **Last-Modified**：资源最后修改时间\n- **Expires**：缓存过期的绝对时间（HTTP/1.0，已过时）\n- **Age**：资源在代理缓存中存在的时间\n- **Vary**：指定哪些请求头会影响缓存版本\n\n**请求头（Request Headers）**：\n- **If-None-Match**：配合 ETag 使用，发送之前保存的 ETag 值\n- **If-Modified-Since**：配合 Last-Modified 使用\n- **Cache-Control**：客户端可以使用 no-cache、no-store、max-age=0 等指令\n\n**缓存工作流程**：\n1. 强缓存：检查 Cache-Control/Expires 是否过期，未过期直接使用缓存\n2. 协商缓存：缓存过期后，携带 If-None-Match/If-Modified-Since 向服务器验证，服务器返回 304（未变）或 200（已变）\n\n**优先级关系**：\n- Cache-Control > Expires\n- ETag > Last-Modified\n\n### 2. ETag 的强验证 vs 弱验证\n\n**强 ETag**（`ETag: \"abc123\"`）：\n- 表示资源字节级完全相同\n- 任何字节变化都会导致 ETag 改变\n- 可用于范围请求（Range）\n\n**弱 ETag**（`ETag: W/\"abc123\"`）：\n- 表示资源语义等价，但字节可能不同\n- 忽略无关紧要的差异（如时间戳、空白字符）\n- **不能用于范围请求**\n\n**弱验证的使用场景**：\n- 动态生成的页面，包含时间戳\n- 压缩处理的资源（同一内容不同编码）\n- 自动格式化的 JSON\n- 包含广告或分析代码的页面\n\n**选择建议**：\n- 静态文件、需要断点续传 → 强 ETag\n- 动态 HTML、可能被压缩的资源 → 弱 ETag\n- 不确定时 → 强 ETag（更安全）\n\n### 3. no-cache vs max-age=0\n\n**no-cache**：\n- 可以存储缓存\n- 直接跳过\"检查是否过期\"，强制验证\n- 语义：每次都要问服务器\n\n**max-age=0**：\n- 可以存储缓存\n- 缓存立即过期\n- 走标准的\"检查过期→验证\"流程\n\n**实际效果**：几乎相同，都会导致重新验证，但 `no-cache` 语义更清晰，更推荐使用。\n\n**与 no-store 的区别**：\n- `no-cache` / `max-age=0`：可以缓存，但每次验证（可能返回 304）\n- `no-store`：完全不缓存，每次重新下载（永远返回 200）\n\n### 4. s-maxage vs max-age\n\n**作用范围差异**：\n- **max-age**：对浏览器和 CDN 都生效\n- **s-maxage**：只对 CDN/代理生效，浏览器忽略\n\n**优先级**：当两者同时存在时，CDN 优先使用 s-maxage，浏览器只看 max-age\n\n**典型场景**：\n```http\nCache-Control: max-age=3600, s-maxage=86400",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/%E9%98%BF%E9%87%8C%E4%BA%91%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E9%99%90%E5%88%B6%E4%B8%8E%E6%8E%A5%E5%85%A5%E8%A6%81%E7%82%B9.md",
        "name": "阿里云边缘计算限制与接入要点",
        "description": "核心知识点：- **阿里云边缘计算常见三种形态**：\n  - **ESA（Edge Security Acceleration）**：偏“边缘平台/边缘函数/全站加速 + 安全”，适合请求改写、鉴权、灰度、边缘缓存、轻量逻辑与托管式 SSR（Functions & Pages）。\n  - **ENS（Edge Node Service）**：偏“边缘 IaaS 算力”，适合在边缘节点上运行完整服务进程（如 Node/Java/Go SSR）、容器、网关、推理等。\n  - **ACK@Edge**：偏“边缘 Kubernetes”，适合已有 K8s 体系，做云边协同与边缘节点纳管编排。\n\n- **ESA 侧（边缘函数/平台）典型限制（会直接影响 SSR/网关类业务）**：\n  - **请求/响应大小限制（网关级）**：不同协议对单个请求头或 URL、请求头+URL 总大小、源站响应头总大小存在上限，超限会返回 4xx/5xx。\n  - **Fetch 子请求限制**：单次处理可发起子请求数量存在默认配额；请求 URL 长度、重定向次数、端口（80/443）等有约束。\n  - **运行时模型限制**：偏 Web 标准 API / V8 Isolate，通常不等价于完整 Node.js（文件系统、原生扩展、任意 socket 等能力可能不可用或受限），更适合“HTTP fetch 串联后端”的轻逻辑。\n\n- **ENS 侧（边缘算力）典型限制**：\n  - **配额与规格限制**：实例数量、网卡数量、自定义镜像数量等有默认上限；存储（系统盘/数据盘数量与容量）有上限。\n  - **网络配额限制**：带宽峰值、EIP 数量、单 EIP 带宽等存在默认上限（通常可申请提升）。\n\n- **ACK@Edge 侧典型限制**：\n  - **网络与访问控制要求**：通常要求 VPC；边缘节点纳管、API Server 访问控制白名单、云边通信组件等需要按文档放行域名/IP/网段与配置策略。\n  - **配额/账户要求**：创建集群、负载均衡、EIP、安全组等存在配额上限与前置条件。\n\n- **接入思路（按目标选择）**：\n  - **要在边缘跑“完整 SSR 服务进程”**：优先 ENS（或 ACK@Edge），必要时叠加 ESA 做就近接入 + 安全加速（ESA 回源到 ENS）。\n  - **要“轻量逻辑 + 回源拼装/鉴权/重定向/缓存”**：优先 ESA EdgeRoutine / Functions & Pages。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/AI%20%E5%AF%B9%E8%AF%9D%E6%9E%B6%E6%9E%84%E4%B8%8E%20SSE%20EventSource%20%E5%9F%BA%E7%A1%80.md",
        "name": "AI 对话架构与 SSE EventSource 基础",
        "description": "核心知识点：- **AI 对话前端架构分层（React 内核 + Vue 壳）**：`ai-chat-react` 负责通用对话 UI、消息处理（SSE/状态/渲染）；`ai-chat-vue` 负责编辑器业务集成（占位元素、落画布、参数面板、消费记录等），并通过 `appendChat(container, options)` 把 React 挂载到 Vue 的 DOM 容器里。\n- **协同机制用事件总线解耦**：两端通过 `EventEmitter` 通信。典型链路是用户提交 `submit` → React 建立流式连接 → 解析增量消息 → `updateMessages/updateFilteredMessages/requesting` → Vue 侧监听并执行编辑器动作（如 `addImage/addVideo/addLayout`）与状态同步。\n- **本项目的“流式输出”实现偏 fetch-stream 而非原生 EventSource**：使用 `fetch` 获取 `response.body`，再用 `TransformStream` 做拼包与 JSON 序列解析（`parseJsonSequence`），将 chunk 转成 `{done, data: MessageType[]}` 逐步喂给 `MessageHandler.handleSSEMessage(data, done)`。\n- **消息模型关键点**：`MessageType` 包含 `role`（`user/assistant/function/status/heartbeat`）、`content`（`type/text`）、`messageId/threadId`、`status`（`waiting/loading/finished/stop`）、以及 `extra.localAigc`（工具结果：`tools[] + workId`）。`function_response` 通过 `extra.lastToolMessageId` 回填到对应的 `function_call`。\n- **SSE（概念）**：Server-Sent Events 是服务器→浏览器单向推送的长连接机制，典型 `Content-Type: text/event-stream`，消息以 `event/id/data/retry` 行组织，空行分隔；浏览器端可用原生 `EventSource` 订阅并自动重连。\n- **原生 EventSource 的常见限制**：只能 `GET`、难以自定义请求体/自定义 header（如 `Authorization`），跨域需 CORS 且链路需禁用缓冲；若要更灵活（POST、自定义 header、细粒度取消），常用 `fetch + ReadableStream` 自行实现流解析。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/%E6%A0%B8%E5%BF%83%E7%BD%91%E9%A1%B5%E6%8C%87%E6%A0%87%20CLS%20%E4%B8%8E%20INP%20%E8%AF%A6%E8%A7%A3.md",
        "name": "核心网页指标 CLS 与 INP 详解",
        "description": "核心知识点：- **CLS (Cumulative Layout Shift)**:\n  - **定义**: 衡量页面的视觉稳定性，记录整个生命周期内所有意外布局偏移的累积分数。\n  - **评分标准**: 良好 ≤ 0.1；需要改进 0.1 - 0.25；糟糕 > 0.25。\n  - **计算公式**: `Layout Shift Score = Impact Fraction (影响范围) × Distance Fraction (移动距离)`。\n  - **统计规则**: 采用“会话窗口 (Session Window)”，取所有窗口中得分最高的一个。每个窗口最大持续 5s，窗口内相邻偏移间隔不超过 1s。\n  - **优化建议**: 为图片/视频预留宽高、使用骨架屏、避免在现有内容上方插入动态内容、使用 CSS `transform` 动画。\n\n- **INP (Interaction to Next Paint)**:\n  - **定义**: 衡量页面的整体响应能力，取代了 FID。测量从用户交互到浏览器下一帧绘制的完整耗时。\n  - **评分标准**: 良好 ≤ 200ms；需要改进 200ms - 500ms；糟糕 > 500ms。\n  - **组成部分**: `Input Delay (输入延迟) + Processing Time (处理时间) + Presentation Delay (呈现延迟)`。\n  - **优化建议**: 拆分长任务 (Long Tasks)、减少主线程阻塞、优化事件处理程序逻辑、避免强制同步布局。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/TypeTool%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "TypeTool 实现原理深度解析",
        "description": "核心知识点：### 1. TypeTool 定义与作用\n\n**TypeTool** 是稿定编辑器自研的高性能文字排版引擎，基于 **WebAssembly** 技术，用于替代浏览器原生的文字排版功能。\n\n**核心职责**：\n- **字体解析**：解析 TrueType/OpenType 字体文件，提取字形轮廓和度量信息\n- **文字排版（Shaping）**：处理复杂文字（阿拉伯语、印地语、CJK）、连字、字距调整、双向文字\n- **布局计算（Layout）**：行内排版、换行、对齐、溢出处理\n- **Canvas 绘制**：绘制字形到 Canvas，应用特效（阴影、描边、渐变）\n\n### 2. 技术架构\n\n```\n┌─────────────────────────────────────────┐\n│        编辑器应用层 (TypeScript)          │\n│  TextElementModel → Canvas → Texture     │\n└─────────────────────────────────────────┘\n              ↓\n┌─────────────────────────────────────────┐\n│      TypeTool JavaScript 封装            │\n│  shape() / draw() / drawBackground()     │\n└─────────────────────────────────────────┘\n              ↓\n┌─────────────────────────────────────────┐\n│       WebAssembly 核心 (C++)             │\n│  ┌──────────┐  ┌──────────┐            │\n│  │Harfbuzz  │  │FreeType  │            │\n│  │文字塑形  │  │字体解析  │            │\n│  └──────────┘  └──────────┘            │\n│         自定义布局算法                   │\n└─────────────────────────────────────────┘\n```\n\n**技术栈**：\n- **C++**：核心排版引擎实现\n- **Harfbuzz 8.x**：业界标准文字塑形引擎（Firefox/Chrome/Android 同款）\n- **FreeType 2.x**：成熟的字体渲染引擎\n- **WebAssembly**：编译目标，提供接近原生的性能\n- **Emscripten**：C++ → WebAssembly 编译器\n- **TypeScript/JavaScript**：上层 API 封装\n\n### 3. 核心组件详解\n\n#### 3.1 Harfbuzz - 文字塑形引擎\n\n**文字塑形（Text Shaping）**：将 Unicode 字符序列转换为定位好的字形序列\n\n**处理流程**：\n```\n输入：Unicode 字符序列 \"Hello\"\n  ↓\nHarfbuzz 塑形\n  ├── 字符 → 字形映射\n  ├── 连字处理（fi → ﬁ）\n  ├── 字距调整（AV 间距优化）\n  ├── 上下文替换（阿拉伯语形态）\n  └── 定位计算\n  ↓\n输出：字形序列 + 位置信息\n  [GlyphID: 43, x:0, y:0]\n  [GlyphID: 72, x:24, y:0]\n  ...\n```\n\n**应用场景**：\n- 连字（Ligatures）：fi → ﬁ\n- 字距调整（Kerning）：AV 间距优化\n- 复杂文字：阿拉伯语、印地语、CJK\n- 双向文字（RTL）：希伯来语、阿拉伯语\n\n#### 3.2 FreeType - 字体渲染引擎\n\n**核心功能**：\n- **字体文件解析**：TrueType (.ttf)、OpenType (.otf)、WOFF/WOFF2\n- **字形轮廓获取**：贝塞尔曲线、矢量路径\n- **字体度量信息**：字符宽度、高度、基线、上升/下降高度\n- **字形光栅化**（可选）：矢量 → 位图、抗锯齿\n\n#### 3.3 WebAssembly 实现\n\n**为什么使用 WebAssembly**：\n```\n性能对比：\nJavaScript 排版：100-500ms\nWebAssembly 排版：5-20ms (快 10-50 倍) 🚀\n\n实测数据：\n- 简单文字排版（10 字符）：20ms → 2ms (快 10 倍)\n- 复杂文字排版（100 字符）：150ms → 8ms (快 18 倍)\n- 富文本排版（1000 字符）：1500ms → 50ms (快 30 倍)\n```\n\n**编译流程**：\n```\nC++ 源代码\n  ↓ Emscripten 编译器\nWebAssembly 模块\n  ├── type-tool.wasm (核心引擎，约 2MB)\n  ├── type-tool.js (Glue Code)\n  └── type-tool.d.ts (TypeScript 类型)\n  ↓\n浏览器/Node.js 运行时\n```\n\n### 4. 核心 API 与工作流程\n\n#### 4.1 核心 API\n\n```typescript\ninterface TypeTool {\n  // 排版：计算字形位置\n  shape(model: TextElement, options?: {\n    width?: number;   // 0 表示自动宽度\n    height?: number;  // 0 表示自动高度\n  }): TextLayout;\n  \n  // 绘制背景\n  drawBackground(\n    model: TextElement,\n    ctx: CanvasRenderingContext2D,\n    layout: TextLayout,\n    options?: DrawOptions\n  ): void;\n  \n  // 绘制文字\n  draw(\n    model: TextElement,\n    ctx: CanvasRenderingContext2D,\n    layout: TextLayout,\n    options?: DrawOptions\n  ): void;\n}\n```\n\n#### 4.2 完整工作流程\n\n```\n1. 初始化阶段\n   ├── 加载 TypeTool WebAssembly 模块\n   ├── 初始化 Harfbuzz 和 FreeType\n   └── 注册字体文件\n   \n2. 排版阶段（Shape）\n   输入：TextElementModel\n   ├── 数据转换：EditorModel → TypeToolModel\n   ├── 字体加载：FreeType 解析字体文件\n   ├── 文字塑形：Harfbuzz 处理（字符 → 字形、连字、字距）\n   ├── 布局计算：自定义算法（换行、行高、对齐）\n   └── 输出：TextLayout（glyphs、lines、bbox）\n   \n3. 绘制阶段（Draw）\n   ├── 创建 Canvas（高精度，如 2 倍）\n   ├── 绘制背景：drawBackground()\n   ├── 遍历字形：draw()\n   │   ├── 计算位置\n   │   ├── 绘制阴影\n   │   ├── 绘制描边\n   │   ├── 绘制填充（纯色/图片/渐变）\n   │   └── 应用特效\n   └── 输出：HTMLCanvasElement（高质量位图）\n   \n4. 渲染到屏幕\n   └── Canvas → PixiJS Texture → Sprite → 显示\n```\n\n### 5. 性能优化策略\n\n#### 5.1 编译优化\n- **最高优化级别**：`-O3` 编译选项\n- **代码体积减少**：30-50%\n- **执行速度提升**：20-30%\n\n#### 5.2 SIMD 加速\n- 使用 SIMD 指令并行处理多个字形\n- 向量运算速度提升 2-4 倍\n\n#### 5.3 内存优化\n- **对象池**：复用 Glyph、Line 对象，减少内存分配 90%\n- **字形缓存**：相同字符只加载一次，性能提升 50-80%\n\n#### 5.4 增量更新\n- 位置变化：直接使用缓存布局（0ms）\n- 样式变化：只更新样式，复用排版结果\n\n#### 5.5 并行处理\n- 使用 Web Workers 并行处理多个文字元素\n- 4 个文字元素并行排版，时间缩短为 1/4\n\n### 6. 与浏览器原生对比\n\n| 功能 | 浏览器原生 | TypeTool | 优势方 |\n|------|-----------|----------|--------|\n| **排版速度** | 100-500ms | 10-50ms | TypeTool (快 10-30 倍) 🚀 |\n| **跨平台一致性** | 差异 3-5px | 0px | TypeTool ✅ |\n| **精确控制** | 黑盒 | 完全控制每个字形 | TypeTool ✅ |\n| **复杂文字支持** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | TypeTool |\n| **包体积** | 0 | 1-3MB | 浏览器 |\n| **兼容性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 浏览器 |\n\n**一致性对比**：\n```\n浏览器原生（相同文字在不同平台）：\n├── Chrome (Windows): 宽度 298.5px\n├── Chrome (macOS): 宽度 301.2px\n├── Firefox (Windows): 宽度 299.8px\n├── Safari (macOS): 宽度 302.1px\n└── 差异: 最大 3.6px ❌\n\nTypeTool：\n├── 所有平台: 宽度 300.0px\n└── 差异: 0px ✅ 完全一致\n```\n\n### 7. 为什么需要 TypeTool\n\n**浏览器原生文字渲染的问题**：\n1. **黑盒问题**：无法获取字形位置、无法控制连字/字距、无法自定义排版算法\n2. **一致性问题**：不同浏览器/操作系统渲染不同、前后端渲染不一致\n3. **性能问题**：大量文字元素卡顿、频繁重排重绘、无法并行处理\n4. **功能限制**：特效支持有限、无法实现复杂效果、导出质量问题\n\n**TypeTool 的优势**：\n- ✅ **完全控制**：精确到每个字形的位置和渲染\n- ✅ **跨平台一致**：同一套代码，所有平台结果相同\n- ✅ **高性能**：WebAssembly 接近原生速度\n- ✅ **可扩展**：可以实现任意自定义效果\n\n### 8. 技术选型理由\n\n**为什么选择 WebAssembly**：\n- ❌ 纯 JavaScript 实现：性能差（慢 10-30 倍）\n- ❌ 服务端渲染：网络延迟、服务器成本高\n- ✅ **WebAssembly**：接近原生性能、客户端执行\n\n**为什么选择 Harfbuzz + FreeType**：\n- 业界标准，被广泛应用于 Firefox、Chrome、Android、Linux\n- 经过数十年验证的成熟技术\n- 功能完整，支持各种复杂文字处理\n\n### 9. 关键指标\n\n**性能指标**：\n- 排版速度：5-20ms（简单-复杂）\n- 绘制速度：10-30ms\n- 总耗时：15-50ms\n- 帧率：稳定 60fps ✅\n\n**内存占用**：\n- WASM 模块：1-3MB\n- 运行时内存：5-10MB\n- 总计：6-13MB\n\n**体积指标**：\n- type-tool.wasm：2MB\n- type-tool.js：100KB\n- 总计：2.1MB（gzip 后约 800KB）\n\n**性能提升**：\n- 排版速度：快 10-30 倍 🚀\n- 跨平台一致：0px 差异 ✅\n- 用户满意度：+27% 📈\n\n### 10. 实战应用场景\n\n#### 10.1 基础排版\n```typescript\nconst typeTool = await getTypeTool();\nconst layout = typeTool.shape(model);\nconst glyphs = layout.glyphs(); // 获取所有字形位置\n```\n\n#### 10.2 富文本排版\n- 多种字体混用\n- 不同颜色混排\n- TypeTool 自动处理字体切换和对齐\n\n#### 10.3 自动换行\n- 固定宽度自动换行\n- 智能单词断行（英文）\n- 自动计算高度\n\n#### 10.4 竖排文字\n- 支持 `writing-mode: vertical-rl`\n- 适用于中文古诗等场景\n\n#### 10.5 复杂特效\n- 多层描边\n- 立体阴影\n- 渐变填充\n- 图片纹理填充\n\n---",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Import%20Maps%20%E4%B8%8E%20es-module-shims%20%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88.md",
        "name": "Import Maps 与 es-module-shims 原理及兼容方案",
        "description": "核心知识点：### 1. Import Maps 解决的问题\n\n- **把\"裸模块名\"映射成可加载的 URL**：浏览器原生 `import` 只认识 URL（相对/绝对），不认识 `import \"react\"` 这种\"包名\"。`importmap` 让你在 HTML 里声明映射，从而不用打包也能直接在浏览器跑 ESM。\n- **集中管理依赖入口与版本**：同一个模块名在全站统一指向某个版本/产物，避免每个文件里到处写 CDN URL。\n- **控制子路径与前缀映射**：支持 `\"lodash/\" -> \"/vendor/lodash/\"` 这类前缀映射。\n- **运行时注入/多环境切换更容易**：可以按环境生成不同的 import map（dev 指向本地、prod 指向 CDN）。\n- **本质**：解决\"浏览器 ESM 缺少 Node/打包器那套模块解析（node_modules、package.json exports、版本解析）\"的能力缺口。\n\n### 2. Import Maps 的替代方案\n\n| 方案 | 优点 | 缺点 |\n|------|------|------|\n| 打包器（Vite/Webpack/Rollup/esbuild） | 完整的 npm 解析、tree-shaking、代码分割、压缩等 | 需要构建流程与产物 |\n| 开发期预打包服务（Vite dev server） | 开发体验好，源码仍写裸模块名 | 不是 importmap，是工具解决解析与转换 |\n| CDN + URL 直引 | 最简单，不需要 importmap | 源码到处是 URL，版本分散，可控性差 |\n| 服务器端重写/代理 import | 可控、能做鉴权/内网镜像 | 维护成本高 |\n| SystemJS | 早期解决浏览器模块加载与映射 | 额外 runtime、生态偏老 |\n\n### 3. 不支持 Import Maps 浏览器的兼容方案\n\n**A 类（有 ESM、没 Import Maps）**：\n- 使用 `es-module-shims` 作为 polyfill，是目前事实上的标准方案\n- 用法：`type=\"importmap\"` → `type=\"importmap-shim\"`，`type=\"module\"` → `type=\"module-shim\"`\n- 可用 `HTMLScriptElement.supports?.('importmap')` 做特性检测\n\n**B 类（连 ESM 都不支持）**：\n- 走 **modern/legacy 双产物** 策略\n- `<script type=\"module\">` + `<script nomodule>` 分流\n- 工具：`@vitejs/plugin-legacy`、Webpack Babel 方案\n\n### 4. es-module-shims 实现原理\n\n**核心思路**：在浏览器原生 ESM 运行时之上，补上一层\"解析 import / 解析 importmap / 重写模块源码\"的 loader。\n\n**关键机制**：\n1. **用自定义 script type 接管加载**：`type=\"importmap-shim\"` / `type=\"module-shim\"` 让浏览器忽略，由 shim 接管\n2. **构建 import map 解析表**：收集页面上的 import map，按规范实现 `resolve(specifier, parentURL)`\n3. **解析模块源码 → 找出依赖 → 重写 specifier**：\n   - fetch 模块源码文本\n   - 用轻量 lexer 静态分析 import/export\n   - 对每个 specifier 调用 resolve 得到最终 URL\n   - 字符串层面重写源码\n4. **用 Blob URL 交回给原生 ESM 执行**：`URL.createObjectURL(new Blob([rewrittenCode]))` 然后 `import(blobUrl)`，让浏览器原生模块系统负责执行语义\n\n**限制/副作用**：\n- 有运行时开销（fetch、解析、重写、生成 blob）\n- CSP 需要允许 `blob:`\n- importmap 必须先于模块执行稳定下来\n- 不解决无 ESM 的老浏览器\n\n### 5. 动态 import 裸模块在 shim 模式下的处理\n\n**问题**：入口用 `importShim()` 启动后，模块内部的动态 `import('bare-specifier')` 仍是原生 `import()`，不会被 shim 接管。\n\n**解决方案**：\n\n| 方案 | 改动范围 | 性能影响 | 适用场景 |\n|------|---------|---------|---------|\n| 构建时转换 | 加 vite 插件 | 无额外开销 | **推荐**，适合大量动态 import 场景 |\n| shimMode | 改 HTML 模板 | 全部走 shim | 小项目、需要最大兼容 |\n| polyfill hook | 配置 esmsInitOptions | 不可靠 | 不推荐 |\n\n**推荐方案：构建时转换**\n\n```typescript\n// 构建产物中注入的兼容函数\nconst dynamicImport = typeof importShim !== 'undefined' ? importShim : (m) => import(m);\n\n// 原来的代码：\nimport('@design/business-ui')\n\n// 转换后：\ndynamicImport('@design/business-ui')\n```\n\n可通过 vite 插件在 `renderChunk` 阶段把动态 `import('bare-specifier')` 替换成兼容写法。\n\n---",
        "mimeType": "text/markdown"
      }
    ]
  }
}