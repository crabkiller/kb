{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%20syncCacheProvider%20%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "Web Widget 架构设计与 syncCacheProvider 机制深度解析",
        "description": "核心知识点：- **Web Widget 核心定位**：基于 Web Components 标准的微模块方案，解决 Monorepo 项目中跨团队协作、跨框架混合运行（如 React 中运行 Vue）及渐进式迁移问题。\n- **实现原理**：\n  - **HTMLWebWidgetElement**：自定义元素作为容器，管理 Widget 的生命周期状态（LOADING, LOADED, BOOTSTRAPPED, MOUNTED）。\n  - **生命周期协议**：标准化 `bootstrap`、`mount`、`unmount` 钩子，屏蔽框架差异。\n  - **适配器模式**：通过 `toReact` 等 HOC 在 React 生命周期内管理 Vue 实例，同步 Props 并桥接事件。\n- **syncCacheProvider 机制**：\n  - **SSR 阶段**：阻塞执行 fetcher，将数据存入 `lifecycleCache` 并序列化至 HTML 的 JSON 状态中。\n  - **CSR 阶段**：首屏加载从 JSON 恢复缓存，`syncCacheProvider` 命中缓存后同步返回数据，消除白屏闪烁。若无缓存则退化为异步 Promise。\n- **性能优化**：支持 `loading=\"lazy\"` 按需激活（Hydration），仅在进入视口时初始化运行时。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Layer%20Picker%20%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96.md",
        "name": "Layer Picker 碰撞检测实现原理与优化",
        "description": "核心知识点：### 1. Color Picking 技术原理\n- **核心思想**：为每个可交互元素分配唯一颜色 ID，将所有元素绘制到离屏 Canvas（hitCanvas），点击时读取像素颜色反向查找元素\n- **优势**：精确、统一、高效，可处理不规则形状和透明区域\n- **关键组件**：LayerPicker 类、colorImage 着色函数、transformLayer 变换函数、getLayers 图层提取\n\n### 2. 图像着色算法（colorImage）\n- 通过 **反复绘制自身**（默认15次）消除半透明像素，使 alpha 趋近于 1\n- 使用 `source-in` 混合模式将图像着色为指定颜色\n- 添加 `shadowBlur` 扩展边缘，提高边缘检测精度\n\n### 3. 反复绘制的性能问题\n- 每个元素需要 15 次 `drawImage` 调用，N 个图像需要 15N 次\n- 时间复杂度：O(repeatDrawCount × width × height × N)\n\n### 4. 优化方案对比\n\n| 方案 | 原理 | 性能提升 | 复杂度 |\n|------|------|----------|--------|\n| **ImageData 像素操作** | 直接遍历像素，alpha > 0 设为 255 | ★★★☆☆ | 低 |\n| **lighter 混合模式** | alpha 直接相加，5次即可达到1.0 | ★★★☆☆ | 低 |\n| **WebGL Shader** | GPU 并行处理，fragment shader 着色 | ★★★★★ | 高 |\n| **增量更新** | 缓存已着色结果，只处理变更图层 | ★★★★☆ | 中 |\n\n### 5. Canvas 混合模式的 Alpha 计算\n\n| 模式 | Alpha 公式 | α=0.5 结果 | 效果 |\n|------|------------|------------|------|\n| source-over | `α + α × (1 - α)` | 0.75 | 增加 |\n| **lighter** | `α + α` (clamp to 1) | 1.0 | **增加最快** |\n| screen | `α + α - α × α` | 0.75 | 增加 |\n| multiply | `α × α` | 0.25 | 减少 |\n\n- **lighter 模式最高效**：5次即可将 α=0.1 提升到 1.0（source-over 需要15+次）\n- **无法直接实现 alpha 二值化**：标准混合模式都是连续函数，需配合 ImageData 或 Shader\n\n### 6. 模糊匹配机制\n\n**触发原因**（读取像素颜色与存储颜色不匹配）：\n- 半透明像素与背景混合导致颜色偏移\n- 抗锯齿产生边缘中间色\n- zoom 缩放时浏览器颜色插值\n- 多图层边缘重叠混合\n- `getImageData` 采样边界像素\n\n**保留必要性**：\n- 即使 colorImage 输出完美纯色，后续绘制/采样环节仍可能引入偏差\n- 模糊匹配是整个流程中颜色精度损失的**兜底机制**\n- 配合 `imageSmoothingEnabled = false` 可大幅减少触发频率\n\n### 7. 推荐优化路径\n1. **短期**：将反复绘制替换为 lighter 模式（5次）或 ImageData 像素操作\n2. **中期**：实现增量更新机制，避免全量重绘\n3. **长期**：考虑 WebGL 统一方案",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BB%B7%E5%80%BC%EF%BC%88%E5%85%A8%E9%87%8F%E6%80%9D%E8%80%83%E7%89%88%EF%BC%89.md",
        "name": "Kubernetes (K8s) 核心概念与价值（全量思考版）",
        "description": "核心知识点：- **Kubernetes (K8s) 定义**：开源容器编排平台，用于自动化部署、扩展和管理容器化应用。\n- **架构组成**：\n  - **Control Plane (控制平面)**：决策中心。\n  - **Nodes (节点)**：运行环境，包含 Kubelet 和容器运行时。\n- **核心对象**：\n  - **Pod**：最小调度单位，共享网络和存储。\n  - **Controllers**：Deployment (无状态), StatefulSet (有状态), DaemonSet (全节点副本)。\n  - **Service & Ingress**：服务发现、负载均衡与外部路由管理。\n- **核心价值**：解决大规模容器管理中的自动化运维、服务发现、高可用自愈、资源利用率优化、版本发布风险控制及环境一致性问题。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/CSS%20%E5%B8%83%E5%B1%80%E4%B8%8E%20Grid%20%E7%80%91%E5%B8%83%E6%B5%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "CSS 布局与 Grid 瀑布流深度解析",
        "description": "核心知识点：- **Flex 布局收缩规则 (flex-shrink)**：\n  - 计算公式：`加权收缩量 = 溢出空间 * (flex-basis * flex-shrink) / 总加权值`。\n  - 默认 `flex-shrink: 1`。若所有子元素收缩比例之和小于 1，溢出空间不会被完全吸收。\n  - 易错点：`min-width` 默认为 `auto`，长文本溢出常导致收缩失效，需手动设为 `0`。\n- **Grid 布局核心特性**：\n  - **二维布局**：同时处理行和列。\n  - **自适应黑科技**：`repeat(auto-fill, minmax(200px, 1fr))` 实现无需媒体查询的响应式网格。\n  - **auto-fill vs auto-fit**：`auto-fill` 即使格子为空也保留（留白），`auto-fit` 会折叠空格子（拉伸）。\n- **Grid 瀑布流 (Masonry)**：\n  - `grid-template-rows: masonry` 是 Level 3 规范，允许网格行不再强制对齐，自动填充空隙。\n  - 目前仅 Firefox 实验性支持，生产环境通常需配合 JS 计算 `grid-row-end: span N`。\n- **面试易混淆点**：\n  - `flex: 1` 等价于 `flex-grow: 1; flex-shrink: 1; flex-basis: 0%;`。\n  - `flex-basis` 优先级高于 `width`，但受 `min/max-width` 限制。\n  - `margin: auto` 在 Flex/Grid 容器中可实现垂直水平双向居中。",
        "mimeType": "text/markdown"
      }
    ]
  }
}