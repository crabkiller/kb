{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md",
        "name": "Web Widget 架构与实现原理",
        "description": "核心知识点：@web-widget 是基于 Web Components 的微模块解决方案，用于解决 Monorepo 跨团队协作、跨框架混合运行（React 中运行 Vue）及渐进式架构迁移问题。核心机制包括：容器化组件（自定义元素沙箱）、生命周期协议（bootstrap/mount/unmount）、状态机管理、适配器模式（toReact/toVue）。syncCacheProvider 用于 SSR 数据同步与注水，支持按需激活（Hydration）和多种渲染模式。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BB%B7%E5%80%BC%E6%80%BB%E7%BB%93.md",
        "name": "Kubernetes (K8s) 核心概念与价值总结",
        "description": "核心知识点：- **定义**：K8s 是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用。\n- **核心架构**：\n  - **Control Plane (控制平面)**：集群决策大脑。\n  - **Nodes (节点)**：运行容器的机器，包含 Kubelet 和容器运行时。\n- **最小单位 (Pod)**：K8s 调度的最小单元，可包含一个或多个共享网络和存储的容器。\n- **控制器 (Controllers)**：\n  - **Deployment**：管理无状态应用副本。\n  - **StatefulSet**：管理有状态应用（如数据库）。\n  - **DaemonSet**：确保每个节点运行一个副本。\n- **服务发现与负载均衡**：\n  - **Service**：提供稳定的虚拟 IP 和负载均衡。\n  - **Ingress**：管理外部访问路由（HTTP/HTTPS）。\n- **配置与存储**：\n  - **ConfigMap/Secret**：配置与镜像解耦。\n  - **PV/PVC**：存储抽象层。\n- **核心价值 (解决的问题)**：\n  - **自动化运维**：摆脱手动管理大规模容器的低效。\n  - **自愈能力**：自动重启失败容器，迁移故障节点任务。\n  - **资源利用率**：智能调度，优化硬件使用。\n  - **零停机更新**：支持滚动更新和秒级回滚。\n  - **环境一致性**：屏蔽底层基础设施差异。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC.md",
        "name": "Kubernetes (K8s) 深度解析：概念、架构与核心价值",
        "description": "核心知识点：### 1. K8s 核心架构与组件\n- **Control Plane (控制平面)**：集群决策中心，负责调度、状态维护及响应事件。\n- **Nodes (节点)**：实际运行应用的物理机或虚拟机，运行 Kubelet 和容器运行时（如 containerd）。\n- **Pod**：K8s 最小调度单元，支持多容器共享网络栈和存储卷。\n\n### 2. 控制器与资源管理\n- **Deployment**：管理无状态应用，支持滚动更新与副本控制。\n- **StatefulSet**：为有状态应用提供持久化标识和存储。\n- **Service**：提供稳定的逻辑集合入口，实现服务发现与负载均衡。\n- **Ingress**：集群外部流量的路由管理器（HTTP/HTTPS）。\n\n### 3. K8s 解决的核心问题\n- **自动化运维**：通过声明式配置实现大规模容器的自动管理。\n- **高可用与自愈**：自动检测并重启失败容器，或在健康节点重新调度 Pod。\n- **资源优化**：基于资源请求（Requests）和限制（Limits）实现智能调度，提高硬件利用率。\n- **零停机发布**：内置滚动更新机制，降低版本更替风险。\n- **环境解耦**：屏蔽底层基础设施差异，确保开发、测试、生产环境的一致性。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BB%B7%E5%80%BC%EF%BC%88%E5%85%A8%E9%87%8F%E5%AF%B9%E8%AF%9D%E7%89%88%EF%BC%89.md",
        "name": "Kubernetes (K8s) 核心概念与价值（全量对话版）",
        "description": "核心知识点：- **Kubernetes (K8s) 定义**：开源容器编排平台，用于自动化部署、扩展和管理容器化应用。\n- **架构组成**：\n  - **Control Plane (控制平面)**：决策中心。\n  - **Nodes (节点)**：运行环境，包含 Kubelet 和容器运行时。\n- **核心对象**：\n  - **Pod**：最小调度单位，共享网络和存储。\n  - **Controllers**：Deployment (无状态), StatefulSet (有状态), DaemonSet (全节点副本)。\n  - **Service & Ingress**：服务发现、负载均衡与外部路由管理。\n  - **ConfigMap & Secret**：配置管理。\n  - **PV & PVC**：持久化存储抽象。\n- **核心价值**：解决大规模容器管理中的自动化运维、服务发现、高可用自愈、资源利用率优化、版本发布风险控制及环境一致性问题。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E4%B8%8E%20syncCacheProvider%20%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "Web Widget 架构与 syncCacheProvider 机制深度解析",
        "description": "核心知识点：- **微模块架构定位**：`@web-widget` 是稿定前端基于 Web Components 的微模块方案，核心解决 Monorepo 中的跨框架混合运行（如 React 中运行 Vue）、渐进式迁移及组件解耦部署问题。\n- **实现原理**：\n  - **HTMLWebWidgetElement**：自定义元素作为物理容器，通过 `import` 属性动态加载模块，内置状态机管理（LOADED, BOOTSTRAPPED, MOUNTED）。\n  - **生命周期协议**：标准化 `bootstrap`、`mount`、`unmount` 钩子，屏蔽框架渲染差异。\n  - **toReact 适配器**：通过 React HOC 在 `useEffect` 中初始化 Vue 实例，实现 Props 同步与事件桥接。\n- **syncCacheProvider 机制**：\n  - **SSR 阶段**：阻塞渲染执行 fetcher，将结果存入 `lifecycleCache` 并序列化至 HTML 的 JSON 状态中。\n  - **CSR 阶段**：首屏加载从 JSON 恢复缓存，`syncCacheProvider` 命中缓存后同步返回数据，彻底消除首屏白屏或闪烁。若无缓存则退化为异步 Promise。\n- **性能优化**：支持 `loading=\"lazy\"` 按需激活（Hydration），仅在进入视口时初始化运行时，提升 TTI。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%20syncCacheProvider%20%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "Web Widget 架构设计与 syncCacheProvider 机制深度解析",
        "description": "核心知识点：- **Web Widget 核心定位**：基于 Web Components 标准的微模块方案，解决 Monorepo 项目中跨团队协作、跨框架混合运行（如 React 中运行 Vue）及渐进式迁移问题。\n- **实现原理**：\n  - **HTMLWebWidgetElement**：自定义元素作为容器，管理 Widget 的生命周期状态（LOADING, LOADED, BOOTSTRAPPED, MOUNTED）。\n  - **生命周期协议**：标准化 `bootstrap`、`mount`、`unmount` 钩子，屏蔽框架差异。\n  - **适配器模式**：通过 `toReact` 等 HOC 在 React 生命周期内管理 Vue 实例，同步 Props 并桥接事件。\n- **syncCacheProvider 机制**：\n  - **SSR 阶段**：阻塞执行 fetcher，将数据存入 `lifecycleCache` 并序列化至 HTML 的 JSON 状态中。\n  - **CSR 阶段**：首屏加载从 JSON 恢复缓存，`syncCacheProvider` 命中缓存后同步返回数据，消除白屏闪烁。若无缓存则退化为异步 Promise。\n- **性能优化**：支持 `loading=\"lazy\"` 按需激活（Hydration），仅在进入视口时初始化运行时。",
        "mimeType": "text/markdown"
      }
    ]
  }
}