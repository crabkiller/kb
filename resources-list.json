{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Web%20Widget%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%20syncCacheProvider%20%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "Web Widget 架构设计与 syncCacheProvider 机制深度解析",
        "description": "核心知识点：- **Web Widget 核心定位**：基于 Web Components 标准的微模块方案，解决 Monorepo 项目中跨团队协作、跨框架混合运行（如 React 中运行 Vue）及渐进式迁移问题。\n- **实现原理**：\n  - **HTMLWebWidgetElement**：自定义元素作为容器，管理 Widget 的生命周期状态（LOADING, LOADED, BOOTSTRAPPED, MOUNTED）。\n  - **生命周期协议**：标准化 `bootstrap`、`mount`、`unmount` 钩子，屏蔽框架差异。\n  - **适配器模式**：通过 `toReact` 等 HOC 在 React 生命周期内管理 Vue 实例，同步 Props 并桥接事件。\n- **syncCacheProvider 机制**：\n  - **SSR 阶段**：阻塞执行 fetcher，将数据存入 `lifecycleCache` 并序列化至 HTML 的 JSON 状态中。\n  - **CSR 阶段**：首屏加载从 JSON 恢复缓存，`syncCacheProvider` 命中缓存后同步返回数据，消除白屏闪烁。若无缓存则退化为异步 Promise。\n- **性能优化**：支持 `loading=\"lazy\"` 按需激活（Hydration），仅在进入视口时初始化运行时。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Layer%20Picker%20%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96.md",
        "name": "Layer Picker 碰撞检测实现原理与优化",
        "description": "核心知识点：### 1. Color Picking 技术原理\n- **核心思想**：为每个可交互元素分配唯一颜色 ID，将所有元素绘制到离屏 Canvas（hitCanvas），点击时读取像素颜色反向查找元素\n- **优势**：精确、统一、高效，可处理不规则形状和透明区域\n- **关键组件**：LayerPicker 类、colorImage 着色函数、transformLayer 变换函数、getLayers 图层提取\n\n### 2. 图像着色算法（colorImage）\n- 通过 **反复绘制自身**（默认15次）消除半透明像素，使 alpha 趋近于 1\n- 使用 `source-in` 混合模式将图像着色为指定颜色\n- 添加 `shadowBlur` 扩展边缘，提高边缘检测精度\n\n### 3. 反复绘制的性能问题\n- 每个元素需要 15 次 `drawImage` 调用，N 个图像需要 15N 次\n- 时间复杂度：O(repeatDrawCount × width × height × N)\n\n### 4. 优化方案对比\n\n| 方案 | 原理 | 性能提升 | 复杂度 |\n|------|------|----------|--------|\n| **ImageData 像素操作** | 直接遍历像素，alpha > 0 设为 255 | ★★★☆☆ | 低 |\n| **lighter 混合模式** | alpha 直接相加，5次即可达到1.0 | ★★★☆☆ | 低 |\n| **WebGL Shader** | GPU 并行处理，fragment shader 着色 | ★★★★★ | 高 |\n| **增量更新** | 缓存已着色结果，只处理变更图层 | ★★★★☆ | 中 |\n\n### 5. Canvas 混合模式的 Alpha 计算\n\n| 模式 | Alpha 公式 | α=0.5 结果 | 效果 |\n|------|------------|------------|------|\n| source-over | `α + α × (1 - α)` | 0.75 | 增加 |\n| **lighter** | `α + α` (clamp to 1) | 1.0 | **增加最快** |\n| screen | `α + α - α × α` | 0.75 | 增加 |\n| multiply | `α × α` | 0.25 | 减少 |\n\n- **lighter 模式最高效**：5次即可将 α=0.1 提升到 1.0（source-over 需要15+次）\n- **无法直接实现 alpha 二值化**：标准混合模式都是连续函数，需配合 ImageData 或 Shader\n\n### 6. 模糊匹配机制\n\n**触发原因**（读取像素颜色与存储颜色不匹配）：\n- 半透明像素与背景混合导致颜色偏移\n- 抗锯齿产生边缘中间色\n- zoom 缩放时浏览器颜色插值\n- 多图层边缘重叠混合\n- `getImageData` 采样边界像素\n\n**保留必要性**：\n- 即使 colorImage 输出完美纯色，后续绘制/采样环节仍可能引入偏差\n- 模糊匹配是整个流程中颜色精度损失的**兜底机制**\n- 配合 `imageSmoothingEnabled = false` 可大幅减少触发频率\n\n### 7. 推荐优化路径\n1. **短期**：将反复绘制替换为 lighter 模式（5次）或 ImageData 像素操作\n2. **中期**：实现增量更新机制，避免全量重绘\n3. **长期**：考虑 WebGL 统一方案",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/Kubernetes%20(K8s)%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BB%B7%E5%80%BC%EF%BC%88%E5%85%A8%E9%87%8F%E6%80%9D%E8%80%83%E7%89%88%EF%BC%89.md",
        "name": "Kubernetes (K8s) 核心概念与价值（全量思考版）",
        "description": "核心知识点：- **Kubernetes (K8s) 定义**：开源容器编排平台，用于自动化部署、扩展和管理容器化应用。\n- **架构组成**：\n  - **Control Plane (控制平面)**：决策中心。\n  - **Nodes (节点)**：运行环境，包含 Kubelet 和容器运行时。\n- **核心对象**：\n  - **Pod**：最小调度单位，共享网络和存储。\n  - **Controllers**：Deployment (无状态), StatefulSet (有状态), DaemonSet (全节点副本)。\n  - **Service & Ingress**：服务发现、负载均衡与外部路由管理。\n- **核心价值**：解决大规模容器管理中的自动化运维、服务发现、高可用自愈、资源利用率优化、版本发布风险控制及环境一致性问题。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/CSS%20%E5%B8%83%E5%B1%80%E4%B8%8E%20Grid%20%E7%80%91%E5%B8%83%E6%B5%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "CSS 布局与 Grid 瀑布流深度解析",
        "description": "核心知识点：- **Flex 布局收缩规则 (flex-shrink)**：\n  - 计算公式：`加权收缩量 = 溢出空间 * (flex-basis * flex-shrink) / 总加权值`。\n  - 默认 `flex-shrink: 1`。若所有子元素收缩比例之和小于 1，溢出空间不会被完全吸收。\n  - 易错点：`min-width` 默认为 `auto`，长文本溢出常导致收缩失效，需手动设为 `0`。\n- **Grid 布局核心特性**：\n  - **二维布局**：同时处理行和列。\n  - **自适应黑科技**：`repeat(auto-fill, minmax(200px, 1fr))` 实现无需媒体查询的响应式网格。\n  - **auto-fill vs auto-fit**：`auto-fill` 即使格子为空也保留（留白），`auto-fit` 会折叠空格子（拉伸）。\n- **Grid 瀑布流 (Masonry)**：\n  - `grid-template-rows: masonry` 是 Level 3 规范，允许网格行不再强制对齐，自动填充空隙。\n  - 目前仅 Firefox 实验性支持，生产环境通常需配合 JS 计算 `grid-row-end: span N`。\n- **面试易混淆点**：\n  - `flex: 1` 等价于 `flex-grow: 1; flex-shrink: 1; flex-basis: 0%;`。\n  - `flex-basis` 优先级高于 `width`，但受 `min/max-width` 限制。\n  - `margin: auto` 在 Flex/Grid 容器中可实现垂直水平双向居中。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/%E7%A8%BF%E5%AE%9A%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95(Extension)%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90.md",
        "name": "稿定编辑器扩展(Extension)系统架构设计与链路分析",
        "description": "核心知识点：### 1. 扩展系统三层架构\n\n| 包/目录 | 定位 | 核心内容 |\n|---------|------|----------|\n| `packages/design/extension` | **运行时核心** | `ExtensionManager`、`Extension`、`ExtensionApi`、入口注册 hooks |\n| `packages/design/extension-store` | **状态管理** | Pinia Store，管理菜单/入口的注册、启用/禁用 |\n| `extensions/*` | **扩展实现** | 每个子目录是一个独立扩展，包含 `manifest.json` + `src/index.ts` |\n\n### 2. 三个核心类职责\n\n- **ExtensionManager**：集中管理所有扩展的加载、注册、运行、卸载，维护 `Map<id, Extension>` 映射表\n- **Extension**：单个扩展实例封装，管理生命周期状态（init/register/bootstrap/run/unmount）\n- **ExtensionApi**：扩展可调用的 API 上下文，桥接编辑器核心能力，提供 100+ API 方法\n\n### 3. 扩展生命周期\n\n```\nload → register → bootstrap（懒加载）→ run → unmount\n```\n\n- **load**：解析 ExtensionConfig，创建 Extension 实例\n- **register**：调用 beforeRegister/afterRegister 钩子，注册 UI 入口（此时扩展代码尚未执行）\n- **bootstrap**：用户首次交互时才动态加载代码并执行 activate()\n- **run**：执行具体命令\n- **unmount**：清理所有注册项\n\n### 4. Manifest 声明规范\n\n```typescript\ninterface Manifest<T> {\n  id: string;\n  name: string;\n  main: (options?: T) => Promise<{ activate: (ctx: ExtensionAPI, options?: T) => void }>;\n  ui?: Record<string, () => Promise<{ ResourceStationView?; SettingContainerView? }>> | string;\n  entries?: Partial<Record<EntryTypes, Entry[]>>;\n  commands?: Record<string, { title: string; icon?: string; when?: string; }>;\n  beforeRegister?: (ctx?: ExtensionAPI, options?: T) => void;\n  afterRegister?: (api: ExtensionAPI, options?: T) => void;\n}\n```\n\n### 5. 入口类型（EntryTypes）\n\n- `ResourceActivityBar`：左侧资源栏\n- `SettingContainer`：右侧设置面板\n- `EditorToolbar`：编辑器 toolbar\n- `EditorContextmenu`：右键菜单\n- `FileMenu`：左上角文件菜单\n- `ExportAction`：下载按钮\n- `EditorAddTools`：左侧添加工具\n- `FilterResourceSlot` / `ComponentResourceSlot`：插槽组件\n\n### 6. JS ↔ UI 通信机制\n\n扩展分离为 JS 层（逻辑）和 UI 层（Vue 组件），通过事件系统通信：\n\n```\nJS 层                           UI 层\nctx.postMessage() ────────────► props.on()\nctx.on()          ◄──────────── props.postMessage()\n```\n\nUI 组件通过 props 接收通信方法（`postMessage`、`postMessageToJSAsync`、`on`、`once`）。\n\n### 7. text-rewrite 扩展完整链路\n\n1. **注册阶段**：afterRegister 中注册 4 类入口（属性面板、右键菜单、toolbar、编辑器插件）\n2. **用户触发**：点击任一入口 → openTextRewrite() → 检查登录 → showElementEditor()\n3. **插件激活**：监听 element.$editing && $editingType === 'aiTextRewrite'\n4. **UI 挂载**：onMounted → 隐藏 toolbar → 禁用属性面板 → 调用 OCR API\n5. **OCR 识别**：调用 `new-image-ocr` 接口，解析文字坐标和内容\n6. **用户编辑**：显示 Popup 弹窗，用户修改文本\n7. **AI 生成**：点击应用 → 调用 `TextEdit` API → 插入新元素 → 应用结果\n\n### 8. 设计亮点\n\n| 特性 | 说明 |\n|------|------|\n| 懒加载 | 扩展代码在用户首次交互时才加载执行 |\n| 声明式入口 | 通过 manifest.entries 声明 UI 挂载点 |\n| API 沙箱 | ExtensionApi 作为中间层隔离扩展与编辑器内核 |\n| 插件注册追踪 | registeredItems 统一管理，卸载时自动清理 |\n| 权限集成 | 入口注册时自动校验 permissionCode |",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/AI%20%E9%A2%86%E5%9F%9F%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%20RAG%20%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md",
        "name": "AI 领域核心概念与 RAG 架构深度解析",
        "description": "核心知识点：- **LLM (大语言模型)**：AI 的“大脑”，负责语义理解与文本生成。演进从 RNN 到 Transformer，再到 GPT 系列，解决了机器理解自然语言的问题。\n- **Agent (智能体)**：以 LLM 为核心，具备规划、记忆和工具使用能力的系统。它让 AI 从“对话者”进化为“执行者”，能够自主完成复杂任务。\n- **Skill (技能)**：Agent 的专业插件或指令集。在 Cursor 中表现为 `.mdc` 规则文件，教导 AI 如何利用工具（如 MCP）完成特定业务流程。\n- **MCP (模型上下文协议)**：由 Anthropic 提出的开放标准，解决了 AI 与外部数据源（文件、数据库等）集成成本高、数据孤岛的问题，是 AI 的“神经通路”。\n- **幻觉 (Hallucination)**：指 AI 生成看似合理但事实错误的内容。原因包括训练数据过时、模型的概率预测本质、缺乏实时感知等。\n- **RAG (检索增强生成)**：通过“检索（找资料）+ 生成（总结回答）”的模式，给 AI 提供“开卷考试”的参考书，是降低幻觉、解决时效性问题的核心手段。\n- **RAG 编排器 (Orchestrator)**：负责 RAG 流程的工程化代码逻辑，包含问题改写、向量检索、重排序（Rerank）和提示词组装。它不是简单的 SQL，而是确定性的算法流程。",
        "mimeType": "text/markdown"
      },
      {
        "uri": "https://raw.githubusercontent.com/crabkiller/kb/main/data/HTTP%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.md",
        "name": "HTTP 缓存机制完全指南",
        "description": "核心知识点：### 1. HTTP 缓存请求头和响应头\n\n**响应头（Response Headers）**：\n- **Cache-Control**：最重要的缓存控制字段\n  - `max-age=<秒>`：缓存有效期（相对时间）\n  - `s-maxage=<秒>`：共享缓存（CDN）的有效期，优先级高于 max-age\n  - `no-cache`：可以缓存，但每次使用前必须验证\n  - `no-store`：禁止缓存\n  - `public`：可被任何缓存存储（包括 CDN）\n  - `private`：只能被浏览器缓存\n  - `must-revalidate`：过期后必须向服务器验证\n  - `immutable`：资源永远不会改变\n- **ETag**：资源的唯一标识符，支持强验证和弱验证（W/前缀）\n- **Last-Modified**：资源最后修改时间\n- **Expires**：缓存过期的绝对时间（HTTP/1.0，已过时）\n- **Age**：资源在代理缓存中存在的时间\n- **Vary**：指定哪些请求头会影响缓存版本\n\n**请求头（Request Headers）**：\n- **If-None-Match**：配合 ETag 使用，发送之前保存的 ETag 值\n- **If-Modified-Since**：配合 Last-Modified 使用\n- **Cache-Control**：客户端可以使用 no-cache、no-store、max-age=0 等指令\n\n**缓存工作流程**：\n1. 强缓存：检查 Cache-Control/Expires 是否过期，未过期直接使用缓存\n2. 协商缓存：缓存过期后，携带 If-None-Match/If-Modified-Since 向服务器验证，服务器返回 304（未变）或 200（已变）\n\n**优先级关系**：\n- Cache-Control > Expires\n- ETag > Last-Modified\n\n### 2. ETag 的强验证 vs 弱验证\n\n**强 ETag**（`ETag: \"abc123\"`）：\n- 表示资源字节级完全相同\n- 任何字节变化都会导致 ETag 改变\n- 可用于范围请求（Range）\n\n**弱 ETag**（`ETag: W/\"abc123\"`）：\n- 表示资源语义等价，但字节可能不同\n- 忽略无关紧要的差异（如时间戳、空白字符）\n- **不能用于范围请求**\n\n**弱验证的使用场景**：\n- 动态生成的页面，包含时间戳\n- 压缩处理的资源（同一内容不同编码）\n- 自动格式化的 JSON\n- 包含广告或分析代码的页面\n\n**选择建议**：\n- 静态文件、需要断点续传 → 强 ETag\n- 动态 HTML、可能被压缩的资源 → 弱 ETag\n- 不确定时 → 强 ETag（更安全）\n\n### 3. no-cache vs max-age=0\n\n**no-cache**：\n- 可以存储缓存\n- 直接跳过\"检查是否过期\"，强制验证\n- 语义：每次都要问服务器\n\n**max-age=0**：\n- 可以存储缓存\n- 缓存立即过期\n- 走标准的\"检查过期→验证\"流程\n\n**实际效果**：几乎相同，都会导致重新验证，但 `no-cache` 语义更清晰，更推荐使用。\n\n**与 no-store 的区别**：\n- `no-cache` / `max-age=0`：可以缓存，但每次验证（可能返回 304）\n- `no-store`：完全不缓存，每次重新下载（永远返回 200）\n\n### 4. s-maxage vs max-age\n\n**作用范围差异**：\n- **max-age**：对浏览器和 CDN 都生效\n- **s-maxage**：只对 CDN/代理生效，浏览器忽略\n\n**优先级**：当两者同时存在时，CDN 优先使用 s-maxage，浏览器只看 max-age\n\n**典型场景**：\n```http\nCache-Control: max-age=3600, s-maxage=86400",
        "mimeType": "text/markdown"
      }
    ]
  }
}