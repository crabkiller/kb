# 核心网页指标 CLS 与 INP 详解

## 核心知识点

- **CLS (Cumulative Layout Shift)**:
  - **定义**: 衡量页面的视觉稳定性，记录整个生命周期内所有意外布局偏移的累积分数。
  - **评分标准**: 良好 ≤ 0.1；需要改进 0.1 - 0.25；糟糕 > 0.25。
  - **计算公式**: `Layout Shift Score = Impact Fraction (影响范围) × Distance Fraction (移动距离)`。
  - **统计规则**: 采用“会话窗口 (Session Window)”，取所有窗口中得分最高的一个。每个窗口最大持续 5s，窗口内相邻偏移间隔不超过 1s。
  - **优化建议**: 为图片/视频预留宽高、使用骨架屏、避免在现有内容上方插入动态内容、使用 CSS `transform` 动画。

- **INP (Interaction to Next Paint)**:
  - **定义**: 衡量页面的整体响应能力，取代了 FID。测量从用户交互到浏览器下一帧绘制的完整耗时。
  - **评分标准**: 良好 ≤ 200ms；需要改进 200ms - 500ms；糟糕 > 500ms。
  - **组成部分**: `Input Delay (输入延迟) + Processing Time (处理时间) + Presentation Delay (呈现延迟)`。
  - **优化建议**: 拆分长任务 (Long Tasks)、减少主线程阻塞、优化事件处理程序逻辑、避免强制同步布局。

## 源对话记录 (Q&A)

**Q**: Cumulative Layout Shift (CLS) 指标

**A**: <details>
<summary>AI 思考过程</summary>
用户询问 CLS 指标，我需要解释其定义、评分标准、产生原因、优化方法以及测量工具。
</details>

Cumulative Layout Shift (CLS) 是 Google 提出的 **核心网页指标 (Core Web Vitals)** 之一，用于衡量页面的**视觉稳定性**。

简单来说，CLS 衡量的是：当用户正在阅读或准备点击页面时，内容是否发生了意料之外的跳动。

### 1. 什么是 CLS？
CLS 记录了页面整个生命周期内发生的所有**意外布局偏移**的累积分数。
*   **布局偏移**：一个可见元素在两帧之间改变了起始位置。
*   **意外**：通常指非用户交互（如点击、按键）直接导致的位移。

### 2. CLS 的评分标准
为了提供良好的用户体验，网站应努力将 CLS 分数控制在 **0.1** 或以下。
*   **良好 (Good)**: ≤ 0.1
*   **需要改进 (Needs Improvement)**: 0.1 - 0.25
*   **糟糕 (Poor)**: > 0.25

### 3. 产生 CLS 的常见原因
在前端开发中，以下情况最容易导致布局抖动：
1.  **图片/视频未指定尺寸**：浏览器在加载图片前不知道其高度，加载完成后会突然撑开容器。
2.  **无尺寸的广告、嵌入内容 (Embeds) 或 iframe**：第三方组件动态插入并推开已有内容。
3.  **动态插入的内容**：例如在页面顶部突然出现的“订阅横幅”或“Cookie 提示”。
4.  **字体闪烁 (FOIT/FOUT)**：自定义字体加载慢，导致文字在默认字体和自定义字体切换时尺寸不一，引起排版变化。
5.  **在更新 DOM 前等待网络响应**：例如异步获取数据后才渲染列表，导致下方内容下移。

### 4. 如何优化 CLS？
针对上述原因，可以采取以下措施：

*   **为图片和视频设置宽高属性**：
    ```html
    <!-- 始终提供 width 和 height，浏览器会自动计算 aspect-ratio -->
    <img src="example.jpg" width="640" height="360" alt="...">
    ```
*   **预留空间 (Skeletons)**：对于异步加载的内容（如广告或列表），使用占位图或骨架屏提前占据空间。
*   **避免在现有内容上方插入内容**：除非是响应用户操作（如点击“查看更多”）。
*   **优化字体加载**：
    *   使用 `font-display: swap;` 减少闪烁。
    *   使用 `<link rel="preload">` 预加载关键字体。
*   **使用 CSS Transform 动画**：位移（top/left）会触发重排（Layout），而 `transform: translate()` 不会影响布局，从而不会产生 CLS。

### 5. 如何测量 CLS？
*   **实验室工具 (Lab Tools)**：Lighthouse, Chrome DevTools (Performance 面板)。
*   **实测工具 (Field Tools)**：PageSpeed Insights (Chrome User Experience Report), `web-vitals` JavaScript 库。

**Q**: CLS 评分计算规则

**A**: <details>
<summary>AI 思考过程</summary>
用户希望深入了解 CLS 的具体计算逻辑，包括影响范围、移动距离以及现代的会话窗口规则。
</details>

CLS (Cumulative Layout Shift) 的计算规则主要基于两个数值：**影响范围 (Impact Fraction)** 和 **移动距离 (Distance Fraction)**。

计算公式为：
$$\text{布局偏移分数 (Layout Shift Score)} = \text{影响范围} \times \text{移动距离}$$

### 1. 核心概念详解

#### A. 影响范围 (Impact Fraction)
衡量不稳定元素在两帧之间对视口（Viewport）区域造成的总影响。它是**前一帧**和**当前帧**中，该元素所占据区域的**并集**占视口总面积的比例。

*   **例子**：一个元素占据了视口 25% 的面积。在下一帧中，它向下移动了视口高度的 25%。
*   **计算**：它在第一帧占 25%，第二帧占 25%，但由于位移，它在两帧之间总共“污染”了 50% 的视口区域。此时影响范围就是 **0.5**。

#### B. 移动距离 (Distance Fraction)
衡量不稳定元素在视口中移动的最大距离（水平或垂直方向上的最大值），除以视口的最大维度（宽度或高度）。

*   **例子**：上述元素向下移动了视口高度的 25%。
*   **计算**：移动距离比例就是 **0.25**。

#### C. 最终得分计算
基于上述例子，该次布局偏移的分数为：
$$0.5 (\text{影响范围}) \times 0.25 (\text{移动距离}) = \mathbf{0.125}$$

---

### 2. 现代 CLS 的统计规则：会话窗口 (Session Window)
为了对长期运行的页面（如无限滚动的单页应用）更公平，Google 在 2021 年更新了 CLS 的统计方式，不再是简单的全周期累加，而是取**最大会话窗口得分**。

*   **什么是会话窗口？**
    *   一组连续发生的布局偏移。
    *   **时间限制**：窗口内相邻两次偏移的间隔不超过 **1 秒**。
    *   **总长限制**：单个窗口的最大持续时间为 **5 秒**。
*   **如何取值？**
    *   浏览器会记录多个会话窗口，最终的 CLS 分数是**所有窗口中得分最高的那一个**。

---

### 3. 哪些偏移不计入 CLS？
并不是所有的元素移动都会增加 CLS 分数：

1.  **用户交互后的 500ms 内**：如果布局变化是由用户点击、按键等操作直接触发的（且在 500ms 内发生），会被标记为“预期内”的偏移，不计入分数。
2.  **CSS Transform 动画**：使用 `transform: translate()` 移动元素不会触发重排（Layout），因此不会产生 CLS。
3.  **特定属性变化**：仅改变 `opacity` 或 `color` 等不影响布局的属性。

**Q**: Interaction to Next Paint (INP) 指标详细说明

**A**: <details>
<summary>AI 思考过程</summary>
用户转向另一个核心指标 INP，我需要对比它与 FID 的区别，并解释其构成和优化方向。
</details>

**Interaction to Next Paint (INP)** 是 Google 在 2024 年 3 月正式取代 First Input Delay (FID) 成为 **核心网页指标 (Core Web Vitals)** 的新成员。它用于衡量页面的**整体响应能力**。

与 FID 只测量“第一次”交互且只测量“延迟”不同，INP 测量的是用户在页面停留期间**所有**交互的完整响应时间。

---

### 1. INP 衡量的是什么？
INP 衡量的是从用户发起交互（如点击、触摸或按键）到浏览器**下一帧绘制（Next Paint）**到屏幕上的时间。

一个完整的交互生命周期包含三个阶段，INP 是这三者的总和：
1.  **输入延迟 (Input Delay)**：从用户交互开始，到事件处理程序开始执行的时间（通常由主线程上的其他任务阻塞引起）。
2.  **处理时间 (Processing Time)**：执行 JavaScript 事件处理程序代码所需的时间。
3.  **呈现延迟 (Presentation Delay)**：事件处理完成后，浏览器重新计算布局、绘图并将帧渲染到屏幕上的时间。

### 2. INP 的评分标准
为了提供良好的用户体验，网站应确保 INP 值低于 **200 毫秒**。
*   **良好 (Good)**: ≤ 200ms
*   **需要改进 (Needs Improvement)**: 200ms - 500ms
*   **糟糕 (Poor)**: > 500ms

### 3. INP 与 FID 的区别
| 特性 | First Input Delay (FID) | Interaction to Next Paint (INP) |
| :--- | :--- | :--- |
| **测量范围** | 仅限**首次**交互 | 页面生命周期内的**所有**交互 |
| **测量内容** | 仅测量“输入延迟” | 测量“延迟+处理+渲染”的**完整耗时** |
| **目标** | 衡量加载阶段的响应性 | 衡量整个生命周期的响应性 |
| **状态** | 已废弃 (Deprecated) | **核心网页指标 (Core Web Vitals)** |

### 4. 常见的 INP 性能瓶颈
在类似 `gaoding/meta` 这样的复杂编辑器项目中，INP 容易受以下因素影响：
*   **主线程阻塞**：复杂的 JavaScript 计算（如编辑器中的图层合成、大量 DOM 操作）占用了主线程，导致用户点击后浏览器无法及时响应。
*   **事件处理程序过重**：在 `click` 或 `input` 回调中执行了同步的耗时逻辑。
*   **渲染压力**：交互触发了大规模的重排（Reflow）或重绘（Repaint），导致“呈现延迟”过长。

### 5. 如何优化 INP？

#### A. 减少输入延迟
*   **拆分长任务 (Long Tasks)**：使用 `setTimeout` 或 `requestIdleCallback` 将超过 50ms 的任务拆分成小块，给浏览器喘息的机会去处理用户输入。
*   **减少不必要的 JS 执行**：优化三方脚本，延迟加载非关键逻辑。

#### B. 缩短处理时间
*   **优化算法**：确保事件回调中的逻辑尽可能高效。
*   **非阻塞渲染**：对于非紧急的 UI 更新，可以使用 `React.startTransition` (如果是 React 项目) 或 `scheduler.yield()` 来让出主线程。

#### C. 降低呈现延迟
*   **简化 DOM 结构**：过深的 DOM 树会增加渲染压力。
*   **使用 `content-visibility: auto`**：跳过视口外元素的渲染。
*   **避免强制同步布局**：不要在修改 DOM 后立即读取几何属性（如 `offsetHeight`）。

### 6. 如何测量？
*   **实测数据**：使用 `web-vitals` 库在生产环境收集。
*   **调试工具**：
    *   **Chrome DevTools Performance 面板**：查看 "Interactions" 轨道，它会高亮显示耗时较长的交互及其组成部分。
    *   **Web Vitals 扩展程序**：实时查看当前页面的 INP 值。
