# 编辑器图片与蒙版元素双层变换模型实现分析

## 核心知识点

### 1. 双层变换模型架构

- **外层 Transform（容器变换）**：控制容器在画布上的位置、大小、旋转，定义"视口窗口"
- **内层 ImageTransform（内容变换）**：控制图片在容器内部的缩放、偏移、旋转
- **设计目的**：实现非破坏性裁剪，支持容器与内容的独立操作

### 2. 数据模型核心属性

**ImageElementModel**：
- `left/top/width/height/rotate`：容器属性
- `imageTransform`：图片相对于容器的变换矩阵
- `naturalWidth/naturalHeight`：原始图片像素尺寸
- `$resizing/$imageTransforming`：运行时状态标记

**MaskElementModel**（继承 ImageElementModel）：
- `mask`：图片蒙版 URL（灰度图）
- `maskPath`：矢量蒙版定义（圆角矩形、椭圆、羽化矩形、SVG 路径）
- `fillOpacity`：填充图片透明度

### 3. 仿射变换矩阵

```
| a  c  tx |
| b  d  ty |
| 0  0  1  |
```

- `(a, d)`：缩放因子（无旋转时）
- `(b, c)`：旋转/剪切因子
- `(tx, ty)`：平移量
- 旋转+缩放公式：`a = scaleX * cos(θ)`, `b = scaleX * sin(θ)`, `c = -scaleY * sin(θ)`, `d = scaleY * cos(θ)`

### 4. 渲染流程

**Canvas 渲染**：
```javascript
ctx.save();
ctx.transform(containerMatrix);  // 应用容器变换
ctx.clip();                      // 设置裁剪区域
ctx.transform(imageTransform);   // 应用图片变换
ctx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
ctx.restore();
```

**DOM 渲染**：
```html
<div style="overflow: hidden; transform: matrix(container)">
    <img style="transform-origin: 0 0; transform: matrix(image)">
</div>
```

### 5. imageResize 核心算法

容器缩放时同步更新 imageTransform 以保持视觉一致：
```javascript
const compensateMatrix = new Transform(widthRatio, 0, 0, heightRatio, 0, 0);
srcModel.imageTransform = compensateMatrix.multiply(destModel.imageTransform);
```
使用**前置乘法**：先执行原有变换，再执行补偿缩放。

### 6. 三种蒙版实现方式

| 类型 | 实现 | 适用场景 |
|------|------|----------|
| 矢量蒙版 | Graphics.drawShape() | 圆角矩形、椭圆、SVG 路径 |
| 图片蒙版 | Sprite + 灰度图 | 复杂不规则形状 |
| 羽化蒙版 | DynamicFeatherMask + Shader | 拼图元素无缝过渡 |

### 7. 编辑态交互

- **普通模式**：拖拽操作 `left/top`，角部缩放调用 `imageResize`
- **编辑模式**（双击进入）：拖拽操作 `imageTransform.tx/ty`，需处理容器旋转的坐标转换

### 8. 性能优化策略

- 状态标记（`$resizing`）避免冗余渲染
- 拖拽过程中跳过滤镜/特效渲染
- Texture 缓存复用
- `$clipCache` 存储裁剪状态快照

## 源对话记录 (Q&A)

**Q**: 分析图片元素实现思路，要尽可能细化到每个技术细节，比如缩放、裁剪、变换等。 @domains/editor/packages/editor/infinite-elements/src/image/index.ts 供参考，但不仅限于这一个文件

**A**: <details>
<summary>AI 思考过程</summary>

用户希望我分析图片元素的实现思路，需要深入到技术细节。让我先查看指定的文件以及相关的代码文件。

我需要查看：
1. infinite-elements/src/image/index.ts - 入口文件
2. 相关的 service、methods、renderer 文件
3. 数据模型定义
4. 变换和resize相关的工具函数
</details>

分析图片元素的实现思路，可以从**数据模型（Model）**、**变换逻辑（Transform & Resize）**、**渲染机制（Renderer）**以及**交互服务（Service）**四个维度进行细化。

### 1. 数据模型与核心属性
图片元素在代码中由 `ImageElementModel` 表示，其核心属性决定了图片如何被展示和操作：

*   **基础属性**：`url` (原始图/预览图地址)、`width` / `height` (容器宽高)、`left` / `top` (位置)、`rotate` (旋转角度)。
*   **图片变换属性 (`imageTransform`)**：这是实现"框内图片变换"的关键。它是一个矩阵（Matrix），记录了图片相对于容器的缩放（scale）、位移（position）和旋转。
*   **原始尺寸 (`naturalWidth` / `naturalHeight`)**：记录图片的真实像素尺寸，用于计算初始比例和裁切范围。
*   **状态标识**：`$resizing` (是否正在调整容器大小)、`$imageTransforming` (是否正在调整框内图片)。

### 2. 变换逻辑 (Transformation)
变换分为"容器变换"和"图片变换"两层：

#### 缩放与调整大小 (Resize)
在 `imageResize` 函数中实现（见 `domains/editor/packages/editor/elements/src/utils/resize.ts`）：
*   **等比缩放**：当拖动角部手柄时，通过 `widthRatio` 和 `heightRatio` 计算新的容器尺寸。
*   **内容自适应**：如果开启了 `$adaptive`，缩放容器时会根据比例自动调整 `imageTransform`，确保图片内容在视觉上保持相对位置（例如 Cover 填充模式）。
*   **矩阵同步**：非自适应模式下，通过 `destModel.imageTransform.localTransform.prepend(...)` 将容器的缩放比例应用到图片变换矩阵中，确保图片随容器同步缩放。

#### 变换 (Transform)
*   **容器变换**：应用 CSS `transform: translate(...) rotate(...)` 到容器 DOM。
*   **框内图片变换**：通过 `imageTransform` 属性实现。用户可以在不改变容器大小的情况下，在容器内部移动、缩放图片（即"双击进入编辑模式"后的操作）。

### 3. 裁剪实现思路 (Cropping)
裁剪在本项目中并非物理裁剪图片，而是通过**"容器 + 溢出隐藏 + 内部位移"**实现的逻辑裁剪：

*   **视觉呈现**：容器（Container）的 `width`/`height` 定义了裁剪框的大小，`overflow: hidden` 隐藏超出部分。内部 `<img>` 元素应用 `imageTransform` 矩阵。
*   **裁剪状态 (`editingType`)**：通过 `ImageService.showElementEditor` 切换到裁剪模式（`ImageEditingType.cropper`）。
*   **坐标转换**：
    *   **外框（容器）**：决定了最终在画布上占据的区域。
    *   **内框（图片）**：相对于外框进行偏移和缩放。
*   **替换图片时的自动适配**：在 `replaceImage` 方法中，会根据新图尺寸和容器尺寸计算 `ratio = Math.max(elementWidth / imgWidth, elementHeight / imgHeight)`，实现类似 `background-size: cover` 的初始填充效果。

### 4. 渲染机制 (Rendering)
图片渲染分为 Canvas 渲染和 DOM 渲染（Vue）：

*   **DOM 渲染**：使用 Vue 组件，通过 CSS 属性将 `imageTransform` 转换为 `matrix()` 应用在 `<img>` 标签上。
*   **Canvas 导出 (`BoardRenderer`)**：
    *   调用 `extractor:exportElement` 命令。
    *   在导出时，渲染引擎会解析 `imageTransform` 矩阵，在 Canvas 上通过 `ctx.setTransform()` 应用变换，然后绘制图片。
    *   支持 `pica` 等库进行高质量的缩放处理（`enablePicaResizing`）。

### 5. 交互与服务 (Service)
`ImageService` 负责协调各种交互逻辑：
*   **事件监听**：监听 `element.transformStart/End` 来标记状态，避免在变换过程中触发不必要的重绘或逻辑冲突。
*   **格式刷 (`applyFormatBrush`)**：支持将一个图片的样式（滤镜、裁剪比例等）应用到另一个图片，通过 `mergeProps` 合并属性，并处理蒙版转换。
*   **滤镜处理**：通过 `IllusionService` 应用滤镜，支持异步加载滤镜配置并渲染。

### 总结
图片元素的实现核心在于**双层变换模型**：外层容器负责位置和裁剪窗口，内层 `imageTransform` 负责图片在窗口内的填充状态。这种解耦设计使得缩放、裁剪和旋转可以独立操作且互不干扰。

---

**Q**: 为什么要采用双层变换模型，单层无法满足什么场景

**A**: <details>
<summary>AI 思考过程</summary>

用户想了解双层变换模型的必要性，我需要从实际场景出发解释单层模型的局限性。
</details>

在图形编辑器中，采用**双层变换模型**（即"容器变换"+"内容变换"）而非单层模型，主要是为了解决**"非破坏性裁剪"**与**"独立交互控制"**的核心矛盾。

如果只使用单层变换（所有属性直接作用于图片本身），以下场景将极难实现或体验极差：

### 1. 非破坏性裁剪 (Non-destructive Cropping)
这是双层模型最根本的存在意义。
*   **单层局限**：如果只有一层，裁剪意味着必须物理修改图片的像素或修改图片的 `width/height` 和 `viewBox`。一旦用户想要重新调整裁剪区域（比如把裁剪框往左挪一点），原始图片的溢出部分已经丢失或计算极其复杂。
*   **双层优势**：
    *   **外层（容器）**：定义"视口"大小，决定在画布上看到的形状。
    *   **内层（图片）**：保留原始图片的完整信息。
    *   **场景**：用户双击图片进入编辑模式，可以自由拖动内部图片来更换展示区域，而外框位置保持不动。这在单层模型下几乎无法实现。

### 2. 容器与内容的独立缩放逻辑
*   **场景：等比缩放 vs. 改变裁剪比例**
    *   当用户拖动图片角部时，通常希望**等比缩放**（容器和内容一起变大）。
    *   当用户拖动边框中点时，通常希望**改变裁剪比例**（容器变窄，但内容图片不被挤压变形，只是被遮挡更多）。
*   **单层局限**：单层模型下，修改 `width` 会直接导致图片拉伸变形（Object-fit 虽然能解决显示，但无法精细控制偏移量）。
*   **双层优势**：外层容器修改 `width/height`，内层图片通过 `imageTransform` 矩阵补偿位移和缩放，从而实现"只改框不改图"的交互。

### 3. 复杂的几何变换组合 (Transform Composition)
*   **场景：旋转后的裁剪**
    *   假设图片旋转了 45 度，此时用户想横向拉大裁剪框。
*   **单层局限**：在单层模型中，旋转和缩放都在同一个坐标系下，拉伸操作会受到旋转角度的影响，导致计算极其复杂，容易出现"斜着拉伸"的怪异效果。
*   **双层优势**：
    *   **外层**处理整体的 `rotate` 和 `position`。
    *   **内层**处理相对于容器平面的 `scale` 和 `offset`。
    *   这种**坐标系嵌套**让数学计算变得直观：无论外层怎么旋转，内层永远是在一个局部的矩形坐标系内做平移。

### 4. 蒙版与形状填充 (Masking & Shape Filling)
*   **场景：将图片放入一个圆形或复杂的矢量形状中**
    *   在 `infinite-elements` 中，`mask` 元素也复用了这套逻辑。
*   **单层局限**：图片必须和形状强绑定。
*   **双层优势**：外层容器可以是一个 `SVG Path` 或 `Border Radius` 容器，内层图片可以独立进行"填充（Cover）"、"包含（Contain）"或自定义位置的调整。

### 5. 性能优化与渲染解耦
*   **场景：滤镜与动效**
    *   当对图片应用高斯模糊或滤镜时，如果频繁变动容器位置。
*   **双层优势**：渲染引擎可以缓存内层图片的渲染结果（Texture），只在每一帧修改外层容器的 CSS Transform。这样不需要重新计算复杂的图片像素变换，只需改变 GPU 上的顶点位置即可。

### 总结对比

| 特性 | 单层模型 | 双层模型 (本项目采用) |
| :--- | :--- | :--- |
| **裁剪** | 破坏性，难以二次调整 | 非破坏性，随时调整视口 |
| **变形控制** | 容易导致图片拉伸 | 容器与内容独立，保护图片比例 |
| **数学计算** | 旋转/缩放/位移耦合，极度复杂 | 坐标系嵌套，逻辑清晰 |
| **交互体验** | 只能整体操作 | 支持"编辑模式"，可独立操作内容 |

这种设计思路类似于 Photoshop 中的**"剪切蒙版 (Clipping Mask)"**或 Figma 中的**"Frame"**概念，是专业级图形编辑器的标配。

---

**Q**: 详细讲解 transform 和 imageTransform 在渲染过程中的实现细节

**A**: <details>
<summary>AI 思考过程</summary>

用户希望深入了解渲染过程中两层变换的具体实现，我需要从坐标空间、矩阵运算和渲染指令三个层面详细解释。
</details>

在渲染过程中，`transform`（外层容器变换）和 `imageTransform`（内层内容变换）的实现细节涉及到**坐标空间嵌套**、**矩阵运算**以及**最终的渲染指令生成**。

以下是基于代码实现（Canvas 渲染与 DOM 渲染）的详细拆解：

### 1. 坐标系层级结构
在渲染树中，图片元素被拆分为两个层级：

1.  **World Space (世界坐标系)**：画布的全局坐标。
2.  **Element Space (元素坐标系)**：由 `transform` 决定，原点通常在元素的左上角或中心。
3.  **Content Space (内容坐标系)**：由 `imageTransform` 决定，相对于元素坐标系进行偏移、缩放和旋转。

### 2. 外层 `transform` 的实现
外层变换决定了图片"框"在画布上的位置和姿态。

*   **数据构成**：主要包含 `left`, `top`, `width`, `height`, `rotate`。
*   **矩阵生成**：
    渲染引擎会将这些属性转换为一个标准 3x3 矩阵 $M_{ext}$：
    $$M_{ext} = Translate(left, top) \times Rotate(rotate) \times Scale(1, 1)$$
    *(注：外层缩放通常直接体现在 width/height 的数值变化上，而非矩阵缩放，以保持边框等属性不被拉伸)*。
*   **CSS/DOM 实现**：
    ```css
    .element-container {
        position: absolute;
        left: 0; top: 0;
        width: {width}px; height: {height}px;
        transform: translate({left}px, {top}px) rotate({rotate}deg);
    }
    ```

### 3. 内层 `imageTransform` 的实现
内层变换决定了图片在"框"内部如何填充。

*   **数据构成**：在代码中（参考 `imageResize` 逻辑），它是一个 `Transform` 对象，包含 `position` (x, y), `scale` (x, y), `rotation`。
*   **矩阵生成**：
    生成内容矩阵 $M_{int}$：
    $$M_{int} = Translate(tx, ty) \times Rotate(rotation) \times Scale(sx, sy)$$
*   **关键细节：裁剪（Clipping）**
    为了实现裁剪效果，外层容器必须设置 `overflow: hidden`。内层图片相对于容器原点进行变换。

### 4. 渲染过程中的矩阵级联 (Canvas 示例)
当 `BoardRenderer` 调用渲染引擎导出图片时，其核心逻辑如下：

```javascript
// 伪代码：渲染引擎内部实现
function drawImageElement(ctx, element) {
    const { left, top, width, height, rotate, imageTransform, url } = element;

    ctx.save();

    // --- 第一步：应用外层变换 ---
    ctx.translate(left, top);
    ctx.rotate(rotate * Math.PI / 180);
    
    // 建立裁剪区域（即"框"）
    ctx.beginPath();
    ctx.rect(0, 0, width, height);
    ctx.clip(); 

    // --- 第二步：应用内层变换 ---
    const { a, b, c, d, tx, ty } = imageTransform.matrix;
    ctx.transform(a, b, c, d, tx, ty);

    // --- 第三步：绘制原始图片 ---
    const img = cache.get(url);
    ctx.drawImage(img, 0, 0, element.naturalWidth, element.naturalHeight);

    ctx.restore();
}
```

### 5. 变换同步逻辑 (Resize 细节)
在 `domains/editor/packages/editor/elements/src/utils/resize.ts` 中，可以看到两者是如何同步的：

```typescript
// 当用户拉伸外框时
export function imageResize(srcModel, destModel, options) {
    const { widthRatio, heightRatio } = options;
    
    // 更新内层矩阵以补偿外层的缩放
    destModel.imageTransform.updateLocalTransform();
    srcModel.imageTransform.setFromMatrix(
        destModel.imageTransform.localTransform.clone().prepend({
            a: widthRatio,
            d: heightRatio,
            // ...
        }),
    );
}
```

### 6. 核心技术点总结

1.  **矩阵乘法 (Concatenation)**：最终图片上任意一点 $P$ 在画布上的位置 $P'$ 为：
    $$P' = M_{ext} \times M_{int} \times P$$
2.  **非线性解耦**：
    *   **旋转**：外层旋转是绕元素中心或左上角旋转；内层旋转是图片在框内自转（常见于图片纠偏）。
    *   **缩放**：外层缩放改变 `width/height`（改变裁剪范围）；内层缩放改变 `scale`（改变图片显示大小）。
3.  **坐标对齐**：
    在 `replaceImage` 时，系统会计算一个初始的 `imageTransform`，使得图片能够以 `cover` 或 `contain` 的方式居中对齐到 `width/height` 定义的框内。

这种实现的精妙之处在于：**渲染器只需要关心最终合成的矩阵，而交互逻辑可以分别独立修改 $M_{ext}$ 或 $M_{int}$。**

---

**Q**: 参照编辑器代码，实现一个简化版图片编辑示例，代码放在「/Users/tudou/Desktop/test/image」目录中：
1. 需要实现 DOM 和 canvas 两个版本，且尽可能抽离复用通用逻辑代码
2. 代码要尽可能详细描述实现原理，以注释方式
3. 数据模型基于编辑器做精简，仅需包含必要属性
4. 图片容器和内容支持独立缩放、旋转等变换
5. 双击进入编辑态，支持容器和内容独立地缩放旋转，容器缩放旋转期间内容在试图中相对位置固定（类似 imageResize 函数功能）

**A**: <details>
<summary>AI 思考过程</summary>

用户希望我创建一个简化版的图片编辑示例，需要：
1. DOM 和 Canvas 两个版本
2. 抽离复用通用逻辑
3. 详细注释说明实现原理
4. 精简的数据模型
5. 支持容器和内容独立变换
6. 双击进入编辑态

让我先规划文件结构，然后逐一创建文件。
</details>

已创建完整的简化版图片编辑器示例，包含以下文件：

### 文件结构

```
/Users/tudou/Desktop/test/image/
├── index.html          # 入口页面，整合 DOM 和 Canvas 两个版本
├── core.js             # 核心模块（Transform 矩阵、ImageElementModel、imageResize）
├── dom-renderer.js     # DOM 渲染器
├── canvas-renderer.js  # Canvas 渲染器
├── interaction.js      # 交互控制器
└── README.md           # 说明文档
```

### 核心实现要点

**1. `core.js` - 核心模块**
- `Transform` 类：2D 仿射变换矩阵封装，支持分解、合成、逆矩阵、点变换
- `ImageElementModel`：精简的数据模型，包含容器属性和 `imageTransform`
- `imageResize()`：核心算法，容器缩放时同步更新内容变换

**2. 双层变换渲染**
- **DOM 版本**：容器使用 `overflow: hidden` + `transform: matrix()`，图片使用 `transform-origin: 0 0` + `matrix()`
- **Canvas 版本**：`ctx.transform()` + `ctx.clip()` + `ctx.drawImage()`

**3. 交互逻辑**
- 普通模式：拖拽/缩放/旋转容器，内容随容器同步变换
- 编辑模式（双击进入）：独立操作图片内容，不影响容器

---

**Q**: 继续分析 mask 元素实现

**A**: <details>
<summary>AI 思考过程</summary>

用户希望我继续分析 mask 元素的实现。让我先查看 mask 元素相关的代码文件，包括 service、methods、utils、renderer 等。
</details>

基于代码分析，以下是 **Mask（蒙版）元素** 的详细实现解析：

### 一、Mask 元素与 Image 元素的关系

Mask 元素是 Image 元素的**扩展**，核心区别在于增加了**裁剪形状**的控制能力：

```
ImageElementModel
       ↓ 继承
MaskBaseElementModel
       ↓ 新增属性
  - mask: string      // 图片蒙版 URL（用于复杂形状裁剪）
  - maskPath: MaskShape  // 矢量蒙版定义（圆角、椭圆、路径等）
```

### 二、核心数据模型

#### 1. MaskShape 类型定义

```typescript
type MaskShape = 
  | { type: 'rounded-rectangle', radius: number | number[], path: string }
  | { type: 'ellipse', eccentricity: number, path: string }
  | { type: 'rectangle-feather', radius: number, edges?: number[] }
  | { type: 'path', path: string }
```

### 三、三种蒙版实现方式

1. **矢量蒙版 (Graphics Mask)**：使用 `maskPath` 定义形状，Canvas 中用 `Graphics.drawShape()` 绘制
2. **图片蒙版 (Sprite Mask)**：使用 `mask` URL 加载灰度图，白色区域可见
3. **羽化蒙版 (Feather Mask)**：边缘带渐变过渡效果，使用 Shader 实现

### 四、蒙版与图片内容的变换同步

- `resizeMaskRadius`：容器缩放时圆角自适应
- `fitImageRect`：蒙版尺寸变化时重新计算图片填充位置
- `adaptMaskRadiusOnResizing`：非等比缩放时限制圆角不超过短边一半

### 五、渲染流程（MaskVm）

```
render(prevState, nextState)
  ├─ isAnimated → useAnimatedImage()
  └─ 静态图片 → useImageContent()
  
renderMask()
  ├─ maskPath.type === 'rectangle-feather' → useFeatherMask()
  ├─ maskPath (其他类型) → useGraphicsMask()
  ├─ mask (URL) → useSpriteMask()
  └─ 无蒙版但 imageTransform 不完全适配 → useGraphicsMask() 矩形裁剪
```

---

**Q**: 你作为面试官，我作为面试者且是图片元素和 mask 元素的开发人员，你会提哪些问题，基于渲染和后续交互，深入浅出

**A**: <details>
<summary>AI 思考过程</summary>

用户希望我作为面试官，针对图片元素和 mask 元素的实现，提出一些深入浅出的面试问题。这些问题应该涵盖渲染和交互两个方面，从基础到深入。
</details>

作为面试官，我会从以下几个层次提问：

### 一、基础概念与设计思路
1. 为什么采用双层变换模型？
2. 图片元素和 Mask 元素的关系是什么？

### 二、渲染实现细节
3. 描述一下图片元素的完整渲染流程
4. `imageTransform` 矩阵是如何应用的？
5. Mask 元素有几种蒙版实现方式？各自适用于什么场景？

### 三、交互逻辑
6. 容器缩放时，内部图片是如何保持视觉一致性的？
7. 双击进入编辑态后，交互逻辑有什么变化？
8. 替换图片时，如何保证新图片自动适配容器？

### 四、性能与优化
9. 渲染性能方面做了哪些优化？
10. 蒙版图片加载是异步的，如何处理加载中状态？

### 五、边界场景与兼容性
11. 如何处理 GIF/APNG 动图？
12. 蒙版元素在拼图场景下有什么特殊处理？

### 六、架构设计思考
13. 如果让你重新设计这套系统，你会做什么改进？
14. 如何保证 DOM 渲染和 Canvas 渲染的结果一致？

### 加分题
15. 如果要支持 3D 透视变换，现有架构需要做什么调整？

---

**Q**: 作为面试者，你会如何回答面试官提的问题

**A**: <details>
<summary>AI 思考过程</summary>

用户希望我作为面试者来回答之前提出的面试问题。我需要基于之前分析的代码和技术细节，给出专业、有深度的回答。
</details>

以下是作为面试者的详细回答（涵盖所有 15 个问题）：

### 1. 为什么采用双层变换模型？

双层变换模型是为了实现**非破坏性裁剪**。`transform` 控制容器位置/旋转，`imageTransform` 控制图片在容器内的填充。如果只用一层，裁剪后想调整区域会非常困难，且无法区分"移动容器"和"移动内容"。

### 2. 图片元素和 Mask 元素的关系？

Mask 继承自 Image，新增 `mask`（图片蒙版 URL）和 `maskPath`（矢量蒙版定义）。单独抽成类型是因为渲染路径不同、交互差异大、避免数据模型膨胀。

### 3. 图片元素完整渲染流程？

Canvas：`ctx.save()` → 应用容器变换 → `ctx.clip()` 设置裁剪区域 → 应用 imageTransform → `ctx.drawImage()` → `ctx.restore()`

### 4. imageTransform 矩阵如何应用？

6 参数仿射矩阵 `(a,b,c,d,tx,ty)`，`transform-origin` 必须是 `0 0` 以保证和手动计算的矩阵一致。

### 5. 三种蒙版实现方式？

矢量蒙版（Graphics）、图片蒙版（Sprite + 灰度图）、羽化蒙版（Shader）。心形蒙版选图片蒙版，设计师提供灰度图更高效。

### 6. 容器缩放时如何保持视觉一致？

`imageResize` 使用前置乘法：`compensateMatrix.multiply(destModel.imageTransform)`，先执行原有变换再执行补偿缩放。

### 7. 编辑态交互变化？

普通模式操作 `left/top`，编辑模式操作 `imageTransform.tx/ty`。需处理容器旋转的坐标转换（逆向旋转 dx/dy）。

### 8. 替换图片如何自动适配？

`Math.max(elementWidth/imgWidth, elementHeight/imgHeight)` 实现 Cover 模式，然后计算居中偏移。

### 9. 性能优化？

状态标记避免冗余渲染、拖拽时跳过滤镜、懒渲染（debounce）、Texture 缓存、$clipCache 快照。

### 10. 异步加载状态管理？

`isCompleted` 状态控制，加载中使用旧蒙版，通过 `nextMask === this._state.mask` 检查避免应用过期资源。

### 11. GIF/APNG 处理？

判断 `resourceType`，切换到 `AnimatedImageVm`，销毁静态图 VM，解析完成后通知上层业务动图时长。

### 12. 拼图场景特殊处理？

外溢区域让相邻蒙版边缘重叠，使用羽化蒙版实现边缘渐变过渡。

### 13. 重新设计会做什么改进？

职责更明确的分层、统一的 TransformNode 树结构、声明式渲染、蒙版类型插件化。

### 14. 如何保证 DOM/Canvas 渲染一致？

共用数据模型和矩阵计算逻辑，统一 transform-origin，关键数值取整避免亚像素差异。

### 15. 支持 3D 透视需要什么调整？

扩展为 16 参数 matrix3d，Canvas 需切换到 WebGL，裁剪区域改为四边形路径，处理背面剔除。
